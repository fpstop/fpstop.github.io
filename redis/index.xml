<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Redis on 徐锦平的博客</title>
    <link>http://www.fpstop.com/redis/</link>
    <description>Recent content in Redis on 徐锦平的博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 26 Mar 2017 00:03:10 +0800</lastBuildDate>
    <atom:link href="http://www.fpstop.com/redis/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>redis 使用-hiredis库使用（一） 基本篇 看完本文就可以上手工作了</title>
      <link>http://www.fpstop.com/redis/hiredis1/</link>
      <pubDate>Sun, 26 Mar 2017 00:03:10 +0800</pubDate>
      
      <guid>http://www.fpstop.com/redis/hiredis1/</guid>
      <description>

&lt;p&gt;hiredis 是redis的客户端sdk，可以让程序操作redis。本文先讲建立连接，基本的get/set命令，读写二进制，获取多个结果来讲。假设读者已经了解redis命令了。&lt;/p&gt;

&lt;p&gt;hiredis的代码也包含在redis代码中，redis\deps\hiredis目录下，接口很简单，几乎不用封装就可以用。&lt;/p&gt;

&lt;h1 id=&#34;1-连接redis数据库&#34;&gt;1 连接redis数据库&lt;/h1&gt;

&lt;h2 id=&#34;1-1-无超时时间-阻塞&#34;&gt;1.1 无超时时间，阻塞&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;redisContext *redisConnect(const char *ip, int port); 
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;1-2-设置超时时间-阻塞&#34;&gt;1.2 设置超时时间，阻塞&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;redisContext *redisConnectWithTimeout(const char *ip, int port, const struct timeval tv);  
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;1-3-非阻塞-立刻返回-也就无所谓超时&#34;&gt;1.3 非阻塞，立刻返回，也就无所谓超时&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;redisContext *redisConnectNonBlock(const char *ip, int port);
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;2-执行命令&#34;&gt;2 执行命令&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;void *redisCommand(redisContext *c, const char *format, ...);
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;2-1-返回值&#34;&gt;2.1 返回值&lt;/h2&gt;

&lt;p&gt;返回值是redisReply类型的指针：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/* This is the reply object returned by redisCommand() */
typedef struct redisReply {
    int type; /* REDIS_REPLY_* */
    PORT_LONGLONG integer; /* The integer when type is REDIS_REPLY_INTEGER */
    int len; /* Length of string */
    char *str; /* Used for both REDIS_REPLY_ERROR and REDIS_REPLY_STRING */
    size_t elements; /* number of elements, for REDIS_REPLY_ARRAY */
    struct redisReply **element; /* elements vector for REDIS_REPLY_ARRAY */
} redisReply;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;2-2-返回值类型&#34;&gt;2.2 返回值类型&lt;/h2&gt;

&lt;p&gt;type字段，包含以下几种类型：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#define REDIS_REPLY_STRING 1    //字符串
#define REDIS_REPLY_ARRAY 2     //数组，例如mget返回值
#define REDIS_REPLY_INTEGER 3   //数字类型
#define REDIS_REPLY_NIL 4       //空
#define REDIS_REPLY_STATUS 5    //状态，例如set成功返回的‘OK’
#define REDIS_REPLY_ERROR 6     //执行失败
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;3-基本命令-get-set&#34;&gt;3 基本命令，get，set&lt;/h1&gt;

&lt;h2 id=&#34;3-1-set&#34;&gt;3.1 set&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;redisReply *r1 = (redisReply*)redisCommand(c, &amp;quot;set k v&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;结果：
    type = 5&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;len = 2

str = OK
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;返回的类型5，是状态。str是OK，代表执行成功。&lt;/p&gt;

&lt;h2 id=&#34;3-2-get&#34;&gt;3.2 get&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;redisReply *r2 = (redisReply*)redisCommand(c, &amp;quot;get k&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;结果：
    type = 1&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;len = 1

str = v
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;返回的类型是1，字符串类型，str是‘v’ ，刚才保存的。&lt;/p&gt;

&lt;h1 id=&#34;4-存取二进制&#34;&gt;4 存取二进制&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;char sz[] = { 0,1,2,3,0 };
redisReply *r3 = (redisReply*)redisCommand(c, &amp;quot;set kb %b&amp;quot;,sz,sizeof(sz));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;存二进制的时候，使用%b，后面需要对应两个参数，指针和长度。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;redisReply *r4 = (redisReply*)redisCommand(c, &amp;quot;get kb&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;读取二进制的时候，和普通是一样的，str字段是地址，len字段是长度。&lt;/p&gt;

&lt;h1 id=&#34;5-存取多个值&#34;&gt;5 存取多个值&lt;/h1&gt;

&lt;h2 id=&#34;存多个值&#34;&gt;存多个值&lt;/h2&gt;

&lt;p&gt;拼接字符串就好啦&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;redisReply *r5 = (redisReply*)redisCommand(c, &amp;quot;mset k1 v1 k2 v2&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;取多个值&#34;&gt;取多个值&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;redisReply *r6 = (redisReply*)redisCommand(c, &amp;quot;mget k1 k2&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里主要看返回值里的这两个字段，代表返回值个数和起始地址：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;size_t elements; /* number of elements, for REDIS_REPLY_ARRAY */
struct redisReply **element; /* elements vector for REDIS_REPLY_ARRAY */
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;知道了以上知识，基本可以上手干活了，redis的接口还是很不错的，感觉都不用封装了。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>socket的属性设置 （持续更新）</title>
      <link>http://www.fpstop.com/redis/learn_src1/</link>
      <pubDate>Fri, 24 Mar 2017 21:47:04 +0800</pubDate>
      
      <guid>http://www.fpstop.com/redis/learn_src1/</guid>
      <description>

&lt;p&gt;今天看redis代码时，发现了如下代码，设置阻塞socket的读写超时时间，仔细一看就是简单的设置了一下socket的属性，索性把socket一些属性总结一下。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/* Set read/write timeout on a blocking socket. */
int redisSetTimeout(redisContext *c, const struct timeval tv)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;1-读超时&#34;&gt;1 读超时&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;The timeout, in milliseconds, for blocking receive calls. The default for this option is zero, which indicates that a receive operation will not time out. If a blocking receive call times out, the connection is in an indeterminate state and should be closed.
    注意，linux和windows的参数略不同。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;    bool SetRecvTimeOut(uint32 millisecond)
    {
#ifdef WIN32
        DWORD time = millisecond;
        if (setsockopt(sock, SOL_SOCKET, SO_RCVTIMEO, (const char*)&amp;amp;time, sizeof(DWORD)) == -1) {
            return false;
        }
#else
        struct timeval tv;
        tv.tv_sec = millisecond / 1000;
        tv.tv_usec = (millisecond % 1000) * 1000;
        if (setsockopt(sock, SOL_SOCKET, SO_RCVTIMEO, (const char*)&amp;amp;tv, sizeof(tv)) == -1) {
            return false;
        }
#endif
        return true;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;2-写超时&#34;&gt;2 写超时&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;The timeout, in milliseconds, for blocking send calls. The default for this option is zero, which indicates that a send operation will not time out. If a blocking send call times out, the connection is in an indeterminate state and should be closed.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;注意，linux和windows的参数略不同。

    bool SetSendTimeOut(uint32 millisecond)
    {
#ifdef WIN32
        DWORD time = millisecond;
        if (setsockopt(sock, SOL_SOCKET, SO_SNDTIMEO, (const char*)&amp;amp;time, sizeof(DWORD)) == -1) {
            return false;
        }
#else
        struct timeval tv;
        tv.tv_sec = millisecond / 1000;
        tv.tv_usec = (millisecond % 1000) * 1000;
        if (setsockopt(sock, SOL_SOCKET, SO_SNDTIMEO, (const char*)&amp;amp;tv, sizeof(tv)) == -1) {
            return false;
        }
#endif
        return true;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;3-地址重用&#34;&gt;3 地址重用&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;Allows a socket to bind to an address and port already in use. The SO_EXCLUSIVEADDRUSE option can prevent this.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;一个端口释放后会等待两分钟之后才能再被使用，SO_REUSEADDR是让端口释放后立即就可以被再次使用。&lt;/p&gt;

&lt;p&gt;p2p打洞时也需要设置这个属性。&lt;/p&gt;

&lt;p&gt;公司的网络库貌似都会设置这个属性呢。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;bool SetReUseAddr(int v)
{
    int ret = setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, (const char*)&amp;amp;v, sizeof(v));
    return 0 == ret;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;4-keepalive&#34;&gt;4 keepalive&lt;/h2&gt;

&lt;p&gt;设置心跳包，还可以指定心跳包频率，不过建议还是在逻辑层设计心跳协议，来检查连接存活。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;int val = 1;
setsockopt(fd, SOL_SOCKET, SO_KEEPALIVE, &amp;amp;val, sizeof(val))
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;5-tcp-nodelay&#34;&gt;5 TCP_NODELAY&lt;/h2&gt;

&lt;p&gt;TCP_NODELAY和TCP_CORK基本上控制了包的“Nagle化”，这里我们主要讲TCP_NODELAY.Nagle化在这里的含义是采用Nagle算法把较小的包组装为更大的帧。JohnNagle是Nagle算法的发明人，后者就是用他的名字来命名的，他在1984年首次用这种方法来尝试解决福特汽车公司的网络拥塞问题（欲了解详情请参看IETF RFC 896）。他解决的问题就是所谓的silly window syndrome，中文称“愚蠢窗口症候群”，具体含义是，因为普遍终端应用程序每产生一次击键操作就会发送一个包，而典型情况下一个包会拥有一个字节的数据载荷以及40个字节长的包头，于是产生4000%的过载，很轻易地就能令网络发生拥塞,。Nagle化后来成了一种标准并且立即在因特网上得以实现。它现在已经成为缺省配置了，但在我们看来，有些场合下把这一选项关掉也是合乎需要的。&lt;/p&gt;

&lt;p&gt;现在让我们假设某个应用程序发出了一个请求，希望发送小块数据，比如sns游戏中的点击确定按钮。我们可以选择立即发送数据或者等待产生更多的数据然后再一次发送两种策略。如果我们马上发送数据，那么交互性的以及客户/服务器型的应用程序将极大地受益。例如，当我们正在发送一个较短的请求并且等候较大的响应时，相关过载与传输的数据总量相比就会比较低，而且，如果请求立即发出那么响应时间也会快一些。以上操作可以通过设置套接字的TCP_NODELAY选项来完成，这样就禁用了Nagle算法，在nginx中设置tcp_nodelay on,注意放在http标签里。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;总之这种把小包组成大包的操作应该由逻辑层来做&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;bool SetNoDelay()
{
    int yes = 1;

    if (setsockopt(sock, IPPROTO_TCP, TCP_NODELAY, &amp;amp;yes, sizeof(yes)) == -1) {
        return false;
    }
    return true;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;6-阻塞非阻塞&#34;&gt;6 阻塞非阻塞&lt;/h2&gt;

&lt;p&gt;这个属性应该是最重要最常用的了。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    //1 :non block
    int SetNonBlock(int value)
    {
#ifndef WIN32
        int oldflags = ::fcntl(sock, F_GETFL, 0);
        /* If reading the flags failed, return error indication now. */
        if (oldflags == -1)
            return -1;

        /* Set just the flag we want to set. */
        if (value != 0)
            oldflags |= O_NONBLOCK;
        else
            oldflags &amp;amp;= ~O_NONBLOCK;
        /* Store modified flag word in the descriptor. */
        return ::fcntl(m_iSock, F_SETFL, oldflags);
#else
        if (::ioctlsocket(sock, FIONBIO, (u_long FAR*)&amp;amp;value) == SOCKET_ERROR)
        {
            return -1;
        }

        return 0;
#endif
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上文中的例子&lt;a href=&#34;https://github.com/xjp342023125/Code/blob/master/common/XSock.hpp&#34;&gt;XSock.hpp&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>windows编译redis</title>
      <link>http://www.fpstop.com/redis/windows%E7%BC%96%E8%AF%91redis/</link>
      <pubDate>Sun, 12 Mar 2017 19:31:50 +0800</pubDate>
      
      <guid>http://www.fpstop.com/redis/windows%E7%BC%96%E8%AF%91redis/</guid>
      <description>

&lt;p&gt;假设大家都已经了解redis了，本文只讲redis的windows上的编译。&lt;/p&gt;

&lt;h1 id=&#34;1-windows编译redis&#34;&gt;1.windows编译redis&lt;/h1&gt;

&lt;h2 id=&#34;1-1下载&#34;&gt;1.1下载&lt;/h2&gt;

&lt;p&gt;微软维护了一个windows版本，地址在&lt;a href=&#34;https://github.com/MSOpenTech/redis&#34;&gt;https://github.com/MSOpenTech/redis&lt;/a&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;The Redis project does not officially support Windows.
However, the Microsoft Open Tech group develops and maintains this Windows port targeting Win64.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;redis官方不支持windows编译，但是微软维护了一个windows版本。既然这个出现在redis官网上，想必也是认可的。最起码用来研究学习时没问题的。&lt;/p&gt;

&lt;h2 id=&#34;1-2-编译&#34;&gt;1.2 编译&lt;/h2&gt;

&lt;p&gt;可以用vs2015 直接打开工程文件
- server：&amp;rdquo;\redis-2.8_win\msvs\RedisServer.sln&amp;rdquo;
- Hiredis异步例子：&amp;rdquo;\redis-2.8_win\msvs\HiredisExample\HiredisExample.sln&amp;rdquo;&lt;/p&gt;

&lt;p&gt;server 很顺利的编译通过，但是Hiredis异步例子编译时报了一个错误,是个类型重定义错误。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;\src\win32_interop\win32_types.h(37): error C2371: &#39;off_t&#39;: redefinition; different basic types
&amp;gt;c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\sys\types.h(42): note: see declaration of &#39;off_t&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;很明显，是自己定义的类型和默认的类型重复了。打开 win32_types.h 文件看看：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/* The Posix version of Redis defines off_t as 64-bit integers, so we do the same.
 * On Windows, these types are defined as 32-bit in sys/types.h under and #ifndef _OFF_T_DEFINED
 * So we define _OFF_T_DEFINED at the project level, to make sure that that definition is never included.
 * If you get an error about re-definition, make sure to include this file before sys/types.h, or any other
 * file that include it (eg wchar.h).
 * _off_t is also defined #ifndef _OFF_T_DEFINED, so we need to define it here.
 * It is used by the CRT internally (but not by Redis), so we leave it as 32-bit.
 */
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;原来，微软团队发现redis在Posix体系下，off_t被定义成64位，而在windows下被sys\types.h文件定义成32位。&lt;/p&gt;

&lt;p&gt;sys\types.h&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#ifndef _OFF_T_DEFINED
    #define _OFF_T_DEFINED

    typedef long _off_t; // file offset value

    #if !__STDC__
        typedef _off_t off_t;
    #endif
#endif
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后windows团队就在工程属性里定义了_OFF_T_DEFINED （So we define _OFF_T_DEFINED at the project level），使32位的不生效，用自己定义在文件的，但是为什么还是出现重定义了呢？&lt;/p&gt;

&lt;p&gt;因为他们忘记在工程属性里定义啦，加回来就行拉。。。忘记定义了这个宏，所以默认的就生效了，自己也定义一份，当然编不过了。。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
