<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>徐锦平的博客</title>
    <link>http://www.fpstop.com/</link>
    <description>Recent content on 徐锦平的博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 30 Jul 2017 20:56:52 +0800</lastBuildDate>
    <atom:link href="http://www.fpstop.com/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>libevent 官方文档</title>
      <link>http://www.fpstop.com/third/libevent_doc/</link>
      <pubDate>Sun, 30 Jul 2017 20:56:52 +0800</pubDate>
      
      <guid>http://www.fpstop.com/third/libevent_doc/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;http://www.fpstop.com/libeven_doc/index.html&#34;&gt;libevent&lt;/a&gt; 由于国内被墙，下载了一份备份。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>libuv文档 翻译</title>
      <link>http://www.fpstop.com/third/libuv_doc/</link>
      <pubDate>Sat, 29 Jul 2017 18:10:19 +0800</pubDate>
      
      <guid>http://www.fpstop.com/third/libuv_doc/</guid>
      <description>

&lt;p&gt;libuv的文档直接就是md的，哈哈&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/libuv/libuv/master/img/banner.png&#34; alt=&#34;libuv&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;overview&#34;&gt;Overview&lt;/h2&gt;

&lt;p&gt;libuv is a multi-platform support library with a focus on asynchronous I/O. It
was primarily developed for use by &lt;a href=&#34;http://nodejs.org&#34;&gt;Node.js&lt;/a&gt;, but it&amp;rsquo;s also
used by &lt;a href=&#34;http://luvit.io/&#34;&gt;Luvit&lt;/a&gt;, &lt;a href=&#34;http://julialang.org/&#34;&gt;Julia&lt;/a&gt;,
&lt;a href=&#34;https://github.com/saghul/pyuv&#34;&gt;pyuv&lt;/a&gt;, and &lt;a href=&#34;https://github.com/libuv/libuv/wiki/Projects-that-use-libuv&#34;&gt;others&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;libuv是个多平台的库，专注异步IO。主要为了node.js 开发的。&lt;/p&gt;

&lt;h2 id=&#34;feature-highlights&#34;&gt;Feature highlights&lt;/h2&gt;

&lt;h2 id=&#34;特色&#34;&gt;特色&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Full-featured event loop backed by epoll, kqueue, IOCP, event ports.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;支持全部事件循环，包括。。。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Asynchronous TCP and UDP sockets&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;异步tcp和udp&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Asynchronous DNS resolution&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;异步dns解析（libevent也支持）&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Asynchronous file and file system operations&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;异步文件和文件系统操作。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;File system events&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;文件系统事件。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;ANSI escape code controlled TTY&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;就是在控制台打印出彩色，高亮，粗体的输出，没啥用。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;IPC with socket sharing, using Unix domain sockets or named pipes (Windows)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;进程间通信（IPC），共享socket。基于unix 域socket或者命名管道。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Child processes&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;子进程&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Thread pool&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;线程池&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Signal handling&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;信号处理&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;High resolution clock&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;高精度时钟，不过c++11 已经支持了。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Threading and synchronization primitives&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;线程和同步原语。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;versioning&#34;&gt;Versioning&lt;/h2&gt;

&lt;p&gt;Starting with version 1.0.0 libuv follows the &lt;a href=&#34;http://semver.org/&#34;&gt;semantic versioning&lt;/a&gt;
scheme. The API change and backwards compatibility rules are those indicated by
SemVer. libuv will keep a stable ABI across major releases.&lt;/p&gt;

&lt;p&gt;从1.0.0开始开始符合一个什么标准。&lt;/p&gt;

&lt;h2 id=&#34;community&#34;&gt;Community&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://groups.google.com/group/libuv&#34;&gt;Mailing list&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://webchat.freenode.net?channels=libuv&amp;amp;uio=d4&#34;&gt;IRC chatroom (#libuv@irc.freenode.org)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;documentation&#34;&gt;Documentation&lt;/h2&gt;

&lt;h3 id=&#34;official-api-documentation&#34;&gt;Official API documentation&lt;/h3&gt;

&lt;p&gt;Located in the docs/ subdirectory. It uses the &lt;a href=&#34;http://sphinx-doc.org/&#34;&gt;Sphinx&lt;/a&gt;
framework, which makes it possible to build the documentation in multiple
formats.&lt;/p&gt;

&lt;p&gt;Show different supported building options:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ make help
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Build documentation as HTML:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ make html
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Build documentation as HTML and live reload it when it changes (this requires
sphinx-autobuild to be installed and is only supported on Unix):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ make livehtml
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Build documentation as man pages:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ make man
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Build documentation as ePub:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ make epub
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;NOTE: Windows users need to use make.bat instead of plain &amp;lsquo;make&amp;rsquo;.&lt;/p&gt;

&lt;p&gt;Documentation can be browsed online &lt;a href=&#34;http://docs.libuv.org&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The &lt;a href=&#34;https://github.com/libuv/libuv/tree/master/test&#34;&gt;tests and benchmarks&lt;/a&gt;
also serve as API specification and usage examples.&lt;/p&gt;

&lt;h3 id=&#34;other-resources&#34;&gt;Other resources&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://nikhilm.github.com/uvbook/&#34;&gt;An Introduction to libuv&lt;/a&gt;
&amp;mdash; An overview of libuv with tutorials.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.youtube.com/watch?v=nGn60vDSxQ4&#34;&gt;LXJS 2012 talk&lt;/a&gt;
&amp;mdash; High-level introductory talk about libuv.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/thlorenz/libuv-dox&#34;&gt;libuv-dox&lt;/a&gt;
&amp;mdash; Documenting types and methods of libuv, mostly by reading uv.h.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/thlorenz/learnuv&#34;&gt;learnuv&lt;/a&gt;
&amp;mdash; Learn uv for fun and profit, a self guided workshop to libuv.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;These resources are not handled by libuv maintainers and might be out of
date. Please verify it before opening new issues.&lt;/p&gt;

&lt;h2 id=&#34;downloading&#34;&gt;Downloading&lt;/h2&gt;

&lt;p&gt;libuv can be downloaded either from the
&lt;a href=&#34;https://github.com/libuv/libuv&#34;&gt;GitHub repository&lt;/a&gt;
or from the &lt;a href=&#34;http://dist.libuv.org/dist/&#34;&gt;downloads site&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Starting with libuv 1.7.0, binaries for Windows are also provided. This is to
be considered EXPERIMENTAL.&lt;/p&gt;

&lt;p&gt;Before verifying the git tags or signature files, importing the relevant keys
is necessary. Key IDs are listed in the
&lt;a href=&#34;https://github.com/libuv/libuv/blob/master/MAINTAINERS.md&#34;&gt;MAINTAINERS&lt;/a&gt;
file, but are also available as git blob objects for easier use.&lt;/p&gt;

&lt;p&gt;Importing a key the usual way:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ gpg --keyserver pool.sks-keyservers.net \
  --recv-keys AE9BC059
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Importing a key from a git blob object:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git show pubkey-saghul | gpg --import
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;verifying-releases&#34;&gt;Verifying releases&lt;/h3&gt;

&lt;p&gt;Git tags are signed with the developer&amp;rsquo;s key, they can be verified as follows:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git verify-tag v1.6.1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Starting with libuv 1.7.0, the tarballs stored in the
&lt;a href=&#34;http://dist.libuv.org/dist/&#34;&gt;downloads site&lt;/a&gt; are signed and an accompanying
signature file sit alongside each. Once both the release tarball and the
signature file are downloaded, the file can be verified as follows:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ gpg --verify libuv-1.7.0.tar.gz.sign
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;build-instructions&#34;&gt;Build Instructions&lt;/h2&gt;

&lt;p&gt;For GCC there are two build methods: via autotools or via &lt;a href=&#34;http://code.google.com/p/gyp/&#34;&gt;GYP&lt;/a&gt;.
GYP is a meta-build system which can generate MSVS, Makefile, and XCode
backends. It is best used for integration into other projects.&lt;/p&gt;

&lt;p&gt;To build with autotools:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sh autogen.sh
$ ./configure
$ make
$ make check
$ make install
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;windows&#34;&gt;Windows&lt;/h3&gt;

&lt;p&gt;First, &lt;a href=&#34;https://www.python.org/downloads/&#34;&gt;Python&lt;/a&gt; 2.6 or 2.7 must be installed as it is required by &lt;a href=&#34;http://code.google.com/p/gyp/&#34;&gt;GYP&lt;/a&gt;.
If python is not in your path, set the environment variable &lt;code&gt;PYTHON&lt;/code&gt; to its
location. For example: &lt;code&gt;set PYTHON=C:\Python27\python.exe&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;To build with Visual Studio, launch a git shell (e.g. Cmd or PowerShell)
and run vcbuild.bat which will checkout the GYP code into build/gyp and
generate uv.sln as well as related project files.&lt;/p&gt;

&lt;p&gt;To have GYP generate build script for another system, checkout GYP into the
project tree manually:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git clone https://chromium.googlesource.com/external/gyp.git build/gyp
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;unix&#34;&gt;Unix&lt;/h3&gt;

&lt;p&gt;For Debug builds (recommended) run:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ./gyp_uv.py -f make
$ make -C out
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For Release builds run:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ./gyp_uv.py -f make
$ BUILDTYPE=Release make -C out
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Run &lt;code&gt;./gyp_uv.py -f make -Dtarget_arch=x32&lt;/code&gt; to build &lt;a href=&#34;https://en.wikipedia.org/wiki/X32_ABI&#34;&gt;x32&lt;/a&gt; binaries.&lt;/p&gt;

&lt;h3 id=&#34;os-x&#34;&gt;OS X&lt;/h3&gt;

&lt;p&gt;Run:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ./gyp_uv.py -f xcode
$ xcodebuild -ARCHS=&amp;quot;x86_64&amp;quot; -project uv.xcodeproj \
     -configuration Release -target All
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Using Homebrew:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ brew install --HEAD libuv
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note to OS X users:&lt;/p&gt;

&lt;p&gt;Make sure that you specify the architecture you wish to build for in the
&amp;ldquo;ARCHS&amp;rdquo; flag. You can specify more than one by delimiting with a space
(e.g. &amp;ldquo;x86_64 i386&amp;rdquo;).&lt;/p&gt;

&lt;h3 id=&#34;android&#34;&gt;Android&lt;/h3&gt;

&lt;p&gt;Run:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ source ./android-configure NDK_PATH gyp
$ make -C out
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note for UNIX users: compile your project with &lt;code&gt;-D_LARGEFILE_SOURCE&lt;/code&gt; and
&lt;code&gt;-D_FILE_OFFSET_BITS=64&lt;/code&gt;. GYP builds take care of that automatically.&lt;/p&gt;

&lt;h3 id=&#34;using-ninja&#34;&gt;Using Ninja&lt;/h3&gt;

&lt;p&gt;To use ninja for build on ninja supported platforms, run:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ./gyp_uv.py -f ninja
$ ninja -C out/Debug     #for debug build OR
$ ninja -C out/Release
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;running-tests&#34;&gt;Running tests&lt;/h3&gt;

&lt;p&gt;Run:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ./gyp_uv.py -f make
$ make -C out
$ ./out/Debug/run-tests
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;supported-platforms&#34;&gt;Supported Platforms&lt;/h2&gt;

&lt;p&gt;Microsoft Windows operating systems since Windows XP SP2. It can be built
with either Visual Studio or MinGW. Consider using
&lt;a href=&#34;http://www.microsoft.com/visualstudio/eng/products/visual-studio-2010-express&#34;&gt;Visual Studio Express 2010&lt;/a&gt; or later if you do not have a full Visual
Studio license.&lt;/p&gt;

&lt;p&gt;Linux using the GCC toolchain.&lt;/p&gt;

&lt;p&gt;OS X using the GCC or XCode toolchain.&lt;/p&gt;

&lt;p&gt;Solaris 121 and later using GCC toolchain.&lt;/p&gt;

&lt;p&gt;AIX 6 and later using GCC toolchain (see notes).&lt;/p&gt;

&lt;h3 id=&#34;aix-notes&#34;&gt;AIX Notes&lt;/h3&gt;

&lt;p&gt;AIX support for filesystem events requires the non-default IBM &lt;code&gt;bos.ahafs&lt;/code&gt;
package to be installed.  This package provides the AIX Event Infrastructure
that is detected by &lt;code&gt;autoconf&lt;/code&gt;.
&lt;a href=&#34;http://www.ibm.com/developerworks/aix/library/au-aix_event_infrastructure/&#34;&gt;IBM documentation&lt;/a&gt;
describes the package in more detail.&lt;/p&gt;

&lt;p&gt;AIX support for filesystem events is not compiled when building with &lt;code&gt;gyp&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&#34;patches&#34;&gt;Patches&lt;/h2&gt;

&lt;p&gt;See the &lt;a href=&#34;https://github.com/libuv/libuv/blob/master/CONTRIBUTING.md&#34;&gt;guidelines for contributing&lt;/a&gt;.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>c&#43;&#43;11 右值引用</title>
      <link>http://www.fpstop.com/cpp/right_ref/</link>
      <pubDate>Wed, 21 Jun 2017 06:29:50 +0800</pubDate>
      
      <guid>http://www.fpstop.com/cpp/right_ref/</guid>
      <description>

&lt;p&gt;一直以来以为右值引用的误区终于搞懂了。&lt;/p&gt;

&lt;h1 id=&#34;误区&#34;&gt;误区&lt;/h1&gt;

&lt;h2 id=&#34;误区一-右值引用是编译期通过指针实现的&#34;&gt;误区一：右值引用是编译期通过指针实现的&lt;/h2&gt;

&lt;p&gt;原来以为右值引用是编译期给你完成的，自己不需要做任何事情，就可以实现高效，以为编译期是内部通过指针来实现的。&lt;/p&gt;

&lt;p&gt;右值引用好用，需要自己写&lt;strong&gt;右值引用构造&lt;/strong&gt;和&lt;strong&gt;右值引用拷贝&lt;/strong&gt;，当符合右值转移的条件时，会自动调用下面这两个函数，如果你不写的话，还是会调用拷贝构造函数。&lt;/p&gt;

&lt;hr /&gt;

&lt;pre&gt;&lt;code&gt;A&amp;amp; operator=(const A&amp;amp;&amp;amp; r)
A(const A&amp;amp;&amp;amp; r)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当然stl里面的类都已经写好右值引用构造和右值引用拷贝。&lt;/p&gt;

&lt;h2 id=&#34;右值引用后-右值不再析构&#34;&gt;右值引用后，右值不再析构&lt;/h2&gt;

&lt;p&gt;这个误区产生的原因和上面类似，其实右值还是一个对象，还会正常析构，只不过析构时不再回收资源，资源已经被挪走。&lt;/p&gt;

&lt;h1 id=&#34;右值引用的机制&#34;&gt;右值引用的机制&lt;/h1&gt;

&lt;p&gt;右值引用调用的时机如下：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;参数为右值时。&lt;/li&gt;
&lt;li&gt;参数为左值，但是通过std::move转化为右值时。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;c++11 加入右值引用特性，是给你个机会，当以上两种情况满足其一时，可以调用你写的右值函数，如果你不写，就会调用普通的拷贝构造函数和赋值函数。&lt;/p&gt;

&lt;h1 id=&#34;实验的小例子&#34;&gt;实验的小例子&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;class A
{
public:
    A()
    {
        cout &amp;lt;&amp;lt; &amp;quot;new A&amp;quot; &amp;lt;&amp;lt; endl;
    }
    ~A()
    {
        cout &amp;lt;&amp;lt; &amp;quot;del A&amp;quot; &amp;lt;&amp;lt; endl;
    }

    A(const A&amp;amp; r)
    {
        cout &amp;lt;&amp;lt; &amp;quot;copy A&amp;quot; &amp;lt;&amp;lt; endl;
    }
    A(const A&amp;amp;&amp;amp; r)
    {
        cout &amp;lt;&amp;lt; &amp;quot;&amp;amp;&amp;amp; copy A&amp;quot; &amp;lt;&amp;lt; endl;
    }

    A&amp;amp; operator=(const A&amp;amp; r)
    {
        cout &amp;lt;&amp;lt; &amp;quot;= A&amp;quot; &amp;lt;&amp;lt; endl;
    }
    A&amp;amp; operator=(const A&amp;amp;&amp;amp; r)
    {
        cout &amp;lt;&amp;lt; &amp;quot;&amp;amp;&amp;amp; = A&amp;quot; &amp;lt;&amp;lt; endl;
    }
    string name;
};

static A make_A()
{
    cout &amp;lt;&amp;lt; &amp;quot;&amp;quot;&amp;lt;&amp;lt;endl;
    return A();
}

static void test_move()
{
    A aa = make_A();
    A bb = std::move(aa);
    A ee(bb);
    A cc(std::move(aa));
    A dd(make_A());
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;输出&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;new A
&amp;amp;&amp;amp; copy A
copy A
&amp;amp;&amp;amp; copy A

new A
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>c&#43;&#43;11 thread库</title>
      <link>http://www.fpstop.com/cpp/thread_class/</link>
      <pubDate>Tue, 20 Jun 2017 06:08:32 +0800</pubDate>
      
      <guid>http://www.fpstop.com/cpp/thread_class/</guid>
      <description></description>
    </item>
    
    <item>
      <title>gcore:给运行中的进程生成core文件</title>
      <link>http://www.fpstop.com/linux/gcore/</link>
      <pubDate>Tue, 20 Jun 2017 05:55:59 +0800</pubDate>
      
      <guid>http://www.fpstop.com/linux/gcore/</guid>
      <description>&lt;p&gt;如果遇到服务器出现卡死（死循环）时，可以用这个命令来生成core文件，然后立即重启服务器，再慢慢调试core文件。&lt;/p&gt;

&lt;p&gt;命令: gcore 进程ID&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>GCC中的堆栈保护机制</title>
      <link>http://www.fpstop.com/linux/fstack-protector-strong/</link>
      <pubDate>Thu, 01 Jun 2017 20:31:28 +0800</pubDate>
      
      <guid>http://www.fpstop.com/linux/fstack-protector-strong/</guid>
      <description>

&lt;p&gt;在微软vs系列开发工具，可以开启 “Security Check” 选项，检查栈溢出，在gcc编译器应该也有类似的功能。&lt;/p&gt;

&lt;h1 id=&#34;栈的结构&#34;&gt;栈的结构&lt;/h1&gt;

&lt;p&gt;栈空间的起止位置由ebp和esp寄存器，栈上存有当前函数的参数，返回地址，函数的局部变量。每次调用函数，都会向栈中依次压入参数，返回地址，进入函数后，会预留出函数使用的局部变量的大小。&lt;/p&gt;

&lt;h1 id=&#34;栈溢出的危害&#34;&gt;栈溢出的危害&lt;/h1&gt;

&lt;p&gt;最大的危害会破坏函数的返回地址，“精心的破坏”会让你的函数跳入一个攻击者制定的函数，也就是新闻里常说的“执行任意代码”。&lt;/p&gt;

&lt;h1 id=&#34;防范&#34;&gt;防范&lt;/h1&gt;

&lt;p&gt;vs的Security Check和GCC的堆栈保护机制差不多，都是在返回地址和局部变量插入一个哨兵，由编译器自动插入代码，在函数开始时赋值一个特殊的值，函数退出时检查这个值是否被改变，如果改变了就是栈被破坏了。&lt;/p&gt;

&lt;h1 id=&#34;gcc中的堆栈保护机制&#34;&gt;GCC中的堆栈保护机制&lt;/h1&gt;

&lt;p&gt;gcc 4.9新加入的参数 -fstack-protector-strong&lt;/p&gt;

&lt;p&gt;编译器会自动调整局部变量在内存中的顺序，使char数组排在靠近返回地址。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>日不落的服务器-linux下利用信号捕获崩溃</title>
      <link>http://www.fpstop.com/linux/signal/</link>
      <pubDate>Thu, 25 May 2017 23:11:46 +0800</pubDate>
      
      <guid>http://www.fpstop.com/linux/signal/</guid>
      <description>

&lt;p&gt;windows系统下的异常处理是&lt;strong&gt;try，&lt;/strong&gt;except,linux下可以用信号来模拟捕捉异常，其实我感觉还是windows下的比较好用。&lt;/p&gt;

&lt;p&gt;分两步，设置信号处理函数，设置一个还原点。&lt;/p&gt;

&lt;h1 id=&#34;设置信号处理函数&#34;&gt;设置信号处理函数&lt;/h1&gt;

&lt;p&gt;一般崩溃时都是收到这两个信号。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;::signal(SIGSEGV, KFXDoSigSEGV);
::signal(SIGFPE, KFXDoSigSEGV);
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;设置还原点-一般都是在主循环上面设置&#34;&gt;设置还原点，一般都是在主循环上面设置&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;sigjmp_buf context;//全局对象
.... 
sigsetjmp(gDoSEGV.context,1);//主循环上方

while(1)
{
    main_loop();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;发生异常时&#34;&gt;发生异常时&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;会调用我们设置的信号处理函数，然后会执行siglongjmp，跳转到我们设置的还原点，重新进入主循环。

static void KFXDoSigSEGV(int nSig)
{
    // 打印一些崩溃信息
    siglongjmp(context, 1);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;思考&#34;&gt;思考&lt;/h1&gt;

&lt;p&gt;不能完全依赖这种方法避免服务器崩溃， 不然会掩盖错误。现在的做法时捕捉到崩溃的时候，打印调用堆栈，然后通知研发计数+1，如果连续捕获到1000次崩溃，就走默认处理真正崩溃，每次捕获后立刻通知研发人员查代码。&lt;/p&gt;

&lt;p&gt;如果是低概率的崩溃事件，可以不影响游戏的其他玩家。&lt;/p&gt;

&lt;p&gt;如果是极高概率出现，1000次以后也会真正的崩溃。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>智能指针:指向基类的智能指针与指向子类的智能指针转换</title>
      <link>http://www.fpstop.com/cpp/shared_ptr/</link>
      <pubDate>Thu, 25 May 2017 06:17:57 +0800</pubDate>
      
      <guid>http://www.fpstop.com/cpp/shared_ptr/</guid>
      <description>

&lt;p&gt;以前没仔细想过这个问题，自己以前实现过的也不支持这个操作。昨天重读 &amp;lt;&lt;effective c++&gt;&amp;gt;，&lt;strong&gt;条款45时 运用成员函数模板，接受所有兼容类型&lt;/strong&gt;。发现了这个问题的实现方法。&lt;/p&gt;

&lt;h1 id=&#34;声明基类和子类-a-b&#34;&gt;声明基类和子类，A，B&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;class A
{
public:
    A()
    {
        cout &amp;lt;&amp;lt; &amp;quot;new A&amp;quot;;
    }
    ~A()
    {
        cout &amp;lt;&amp;lt; &amp;quot;del A&amp;quot;;
    }
};

class B :public A
{
public:
    B()
    {
        cout &amp;lt;&amp;lt; &amp;quot;new B&amp;quot;;
    }
    ~B()
    {
        cout &amp;lt;&amp;lt; &amp;quot;del B&amp;quot;;
    }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;子类智能指针转基类智能指针&#34;&gt;子类智能指针转基类智能指针&lt;/h1&gt;

&lt;p&gt;可以的，赋值操作也可以进行&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;std::shared_ptr&amp;lt;B&amp;gt; bbb(new B);
std::shared_ptr&amp;lt;A&amp;gt; aaa(bbb);
std::shared_ptr&amp;lt;A&amp;gt; aaa2 = bbb;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;拷贝构造时，会调用以下拷贝构造函数，is_convertible会检查是否可以转化（继承关系）。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;template&amp;lt;class _Ty2,
class = typename enable_if&amp;lt;is_convertible&amp;lt;_Ty2 *, _Ty *&amp;gt;::value,
    void&amp;gt;::type&amp;gt;
shared_ptr(const shared_ptr&amp;lt;_Ty2&amp;gt;&amp;amp; _Other) _NOEXCEPT
{   // construct shared_ptr object that owns same resource as _Other
this-&amp;gt;_Reset(_Other);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;enable_if这个关键字我还不太会，不过看效果时编译期就可以检查出是否可以转换成功。基类转子类的智能指针时无法编译通过的：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;shared_ptr&amp;lt;A&amp;gt; aaa(new A);
shared_ptr&amp;lt;B&amp;gt; bbb(aaa); // 无法转换

 error C2664: &#39;std::shared_ptr&amp;lt;B&amp;gt;::shared_ptr(std::shared_ptr&amp;lt;B&amp;gt; &amp;amp;&amp;amp;) noexcept&#39;: cannot convert argument 1 from &#39;std::shared_ptr&amp;lt;A&amp;gt;&#39; to &#39;std::nullptr_t&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;另一种转化方法-operator-t&#34;&gt;另一种转化方法：operator T*();&lt;/h1&gt;

&lt;p&gt;游戏项目中是自己实现的智能指针，没有特殊为这种转换写构造函数，而是写了的转换，在上述调用时参数自动转换成T*。
&lt;strong&gt;不过这种实现方法要求引用计数保存在对象中，而不是智能指针&lt;/strong&gt;，因为无法对隐世转换的智能指针增加计数。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>linux编译版本时日志中打印svn版本号</title>
      <link>http://www.fpstop.com/svn/linux_build_with_svn_info/</link>
      <pubDate>Thu, 25 May 2017 05:54:05 +0800</pubDate>
      
      <guid>http://www.fpstop.com/svn/linux_build_with_svn_info/</guid>
      <description>&lt;p&gt;做游戏开发，有很多时候查bug，最后都是发现时因为测试没有替补丁。所以想，如果日志里能把svn当前的版本号打印出来多好，先排除版本问题。&lt;/p&gt;

&lt;p&gt;从svn中提取信息貌似很不容易，后来想到一种取巧的方法：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;编译脚本中，调用 svn info命令，把svn输出的一个文件，命名为 svn_info.h。&lt;/li&gt;
&lt;li&gt;代码包含 svn_info.h,日志中输出svn版本号。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;脚本提取时，用grep过滤一下信息：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;DST=./Common/svn_info.h
rm -rf DST
echo &#39;#ifndef _SVN_INFO_&#39; &amp;gt; $DST
echo &#39;#define _SVN_INFO_&#39; &amp;gt;&amp;gt; $DST

VERSION=`svn info|grep Revision`
echo &#39;  #define SVNINFO &amp;quot;&#39;$VERSION&#39; &#39;$1&#39;&amp;quot; &#39; &amp;gt;&amp;gt; $DST

echo &#39;#endif&#39; &amp;gt;&amp;gt; $DST
#  
echo $VERSION
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后就会生成类似如下的文件：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#ifndef _SVN_INFO_
#define _SVN_INFO_
#define SVNINFO  &amp;quot;Revision: 11111&amp;quot;
#endif
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;很简单吧。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>protobuf的DebugString方法，汉字乱码</title>
      <link>http://www.fpstop.com/third/protobuf_string/</link>
      <pubDate>Mon, 22 May 2017 18:23:27 +0800</pubDate>
      
      <guid>http://www.fpstop.com/third/protobuf_string/</guid>
      <description>

&lt;p&gt;本文不是解决乱码问题，是要提取乱码内容。游戏上线后要做舆情分析，想收集前两日玩家游戏内聊天内容，无奈没有专门的日志，只能从网络库日志提取protobuf的内容。&lt;/p&gt;

&lt;p&gt;网络库会把每条收到的protobuf协议都调用方法，日志打印所有字段的值，但是汉子会打出类似&amp;rdquo;\346\234\211\344\272\272\345\220\227&amp;rdquo;.想把这些编码转化为能看懂的汉子。&lt;/p&gt;

&lt;h1 id=&#34;1-尝试编码转换&#34;&gt;1 尝试编码转换&lt;/h1&gt;

&lt;p&gt;游戏内的聊天文字用的是utf8的格式，不过看着上面的编码有超过256 char最大值的，看着像双字节的unicode，转成unicode后显示也是乱码，后来用utf8，ansi看都是乱码，只好从代码分析是如何打印的了。&lt;/p&gt;

&lt;h1 id=&#34;2-分析debugstring函数&#34;&gt;2 分析DebugString函数&lt;/h1&gt;

&lt;p&gt;最终会调用到下面的函数，原来是八进制的，仔细一看，确实是。所以剩下的就好做了。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// Escapes &#39;src&#39; using C-style escape sequences, and appends the escaped string
// to &#39;dest&#39;. This version is faster than calling CEscapeInternal as it computes
// the required space using a lookup table, and also does not do any special
// handling for Hex or UTF-8 characters.
// ----------------------------------------------------------------------
void CEscapeAndAppend(StringPiece src, string* dest) {
  size_t escaped_len = CEscapedLength(src);
  if (escaped_len == src.size()) {
    dest-&amp;gt;append(src.data(), src.size());
    return;
  }

  size_t cur_dest_len = dest-&amp;gt;size();
  dest-&amp;gt;resize(cur_dest_len + escaped_len);
  char* append_ptr = &amp;amp;(*dest)[cur_dest_len];

  for (int i = 0; i &amp;lt; src.size(); ++i) {
    unsigned char c = static_cast&amp;lt;unsigned char&amp;gt;(src[i]);
    switch (c) {
      case &#39;\n&#39;: *append_ptr++ = &#39;\\&#39;; *append_ptr++ = &#39;n&#39;; break;
      case &#39;\r&#39;: *append_ptr++ = &#39;\\&#39;; *append_ptr++ = &#39;r&#39;; break;
      case &#39;\t&#39;: *append_ptr++ = &#39;\\&#39;; *append_ptr++ = &#39;t&#39;; break;
      case &#39;\&amp;quot;&#39;: *append_ptr++ = &#39;\\&#39;; *append_ptr++ = &#39;\&amp;quot;&#39;; break;
      case &#39;\&#39;&#39;: *append_ptr++ = &#39;\\&#39;; *append_ptr++ = &#39;\&#39;&#39;; break;
      case &#39;\\&#39;: *append_ptr++ = &#39;\\&#39;; *append_ptr++ = &#39;\\&#39;; break;
      default:
        if (!isprint(c)) {
          *append_ptr++ = &#39;\\&#39;;
          *append_ptr++ = &#39;0&#39; + c / 64;
          *append_ptr++ = &#39;0&#39; + (c % 64) / 8;
          *append_ptr++ = &#39;0&#39; + c % 8;
        } else {
          *append_ptr++ = c;
        }
        break;
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;3-提取数据-输出&#34;&gt;3 提取数据，输出&lt;/h1&gt;

&lt;p&gt;第一步先用c++11 的正则表达式提取数据，然后再用strtol 将八进制转化输出即可，代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;quot;stdafx.h&amp;quot;
#include &amp;quot;../../../Com/CFunc.hpp&amp;quot;
#include &amp;quot;../../../Com/CStr.hpp&amp;quot;
#include &amp;quot;../../../Com/CFile.hpp&amp;quot;
#include &amp;lt;regex&amp;gt;
using namespace std;



int main()
{
    linevec_t lines;
    XReadFileLine(&amp;quot;chat.csv&amp;quot;, lines);

    std::regex reg(&amp;quot;\\\\[0-7]{3}&amp;quot;, std::regex_constants::ECMAScript);

    sregex_token_iterator end;
    for (auto s:lines)
    {
        string chat;
        sregex_token_iterator it(s.begin(), s.end(), reg);
        while (it != end)
        {
            //cout &amp;lt;&amp;lt; *it&amp;lt;&amp;lt;&amp;quot; &amp;quot;;
            string ss = *it;
            ++it;

            char sz[4] = {0};
            sz[0] = ss[1];
            sz[1] = ss[2];
            sz[2] = ss[3];
            //cout &amp;lt;&amp;lt; sz;

            int ret = strtol(sz, NULL, 8);
            chat += char(ret);
        }
        cout &amp;lt;&amp;lt; chat &amp;lt;&amp;lt; endl;
    }
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>redis 使用lua脚本提高执行效率</title>
      <link>http://www.fpstop.com/redis/redis_and_lua/</link>
      <pubDate>Sun, 21 May 2017 23:59:24 +0800</pubDate>
      
      <guid>http://www.fpstop.com/redis/redis_and_lua/</guid>
      <description>

&lt;p&gt;主要针对使用redis的同步api。&lt;/p&gt;

&lt;h1 id=&#34;redis的同步api-代价非常昂贵&#34;&gt;redis的同步api，代价非常昂贵&lt;/h1&gt;

&lt;p&gt;redis的同步api，每一次调用都是相当于一次网络通信，而且时阻塞的，如果赶上网络波动或者redis正在保存数据，会占用很多时间的。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;void *redisvCommand(redisContext *c, const char *format, va_list ap)
{
    send request...
    recv result...
    return ...;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;2-适应情景分析&#34;&gt;2 适应情景分析&lt;/h1&gt;

&lt;p&gt;我们使用时，有很多类似下面的操作&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;val1 = redis.command(&amp;quot;get key1&amp;quot;);
if(val1 &amp;gt; 10)
    redis.command(&amp;quot;set val1 100&amp;quot;);
else
    redis.command(&amp;quot;set val1 0&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;简单地说，就是&lt;strong&gt;多次redis api调用，后面的操作以来于前面的执行结果&lt;/strong&gt;。&lt;/p&gt;

&lt;h1 id=&#34;3-使用lua脚本优化&#34;&gt;3 使用lua脚本优化&lt;/h1&gt;

&lt;p&gt;redis server支持lua脚本，使用时相当于客户端把一小段lua脚本发到redis server执行，这个lua脚本可能会有多次操作。&lt;/p&gt;

&lt;p&gt;但是网络通信只有一次，redis server执行完lua脚本把结果返回给客户端，减少网络交互次数。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>游戏服务器漫谈 压力测试带来的思考</title>
      <link>http://www.fpstop.com/net/stress_net/</link>
      <pubDate>Sun, 21 May 2017 21:44:51 +0800</pubDate>
      
      <guid>http://www.fpstop.com/net/stress_net/</guid>
      <description>

&lt;p&gt;游戏终于上线啦，加班结束，来总结一下前一段时间的所学吧。先从上线前的压力测试说起。&lt;/p&gt;

&lt;h1 id=&#34;1-网络相关优化&#34;&gt;1 网络相关优化&lt;/h1&gt;

&lt;h2 id=&#34;1-1-背景&#34;&gt;1.1 背景&lt;/h2&gt;

&lt;p&gt;单位的网络库使用的时候，网络和逻辑处理是两个线程。&lt;/p&gt;

&lt;p&gt;网络线程负责：接收数据, 解析出protobuf结构，放入网络队列。&lt;/p&gt;

&lt;p&gt;逻辑线程负责：从网络队列取出protobuf，处理。&lt;/p&gt;

&lt;h2 id=&#34;1-2-思考-网络线程是否有意义&#34;&gt;1.2 思考：网络线程是否有意义？&lt;/h2&gt;

&lt;p&gt;如果网络线程处理完直接处理，其实也是可以的。但是分离网络线程会避免当逻辑线程处理过慢，导致socket接收缓冲区满了，客户端发送数据失败。不过逻辑线程处理太慢也会导致客户端发出请求没有回应。&lt;/p&gt;

&lt;h2 id=&#34;1-3-优化-逻辑线程-每次处理网络队列的数量应该有个上限&#34;&gt;1.3 优化：逻辑线程，每次处理网络队列的数量应该有个上限&lt;/h2&gt;

&lt;p&gt;逻辑线程的主循环伪代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;while(1)
{
    // 处理网络队列里的请求
    while(!pack.empty())
    {
        Msg *p = pack.pop();
        process(p);
    }
    // 一些其他的循环，例如发送ping包，每隔5分钟发送体力，libevent库的循环。。。
    check_ping();
    check_present_energy();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;压力测试时，因为逻辑线程处理的速度比网络线程慢，所以逻辑线程会一直卡在处理网路请求的循环中，因为pack永远不为空，修改方案是在while循环的条件加上一个每次处理包的个数上限，这样其他循环也会有机会执行。&lt;/p&gt;

&lt;p&gt;发现这个问题是因为测试时，服务器的状态数据是用libevent库写的一个http接口获取的，但是测试时发现调用这个接口一直超时，后来发现时因为libevent的循环一直没有执行。&lt;/p&gt;

&lt;h1 id=&#34;2-mysql数据库相关优化&#34;&gt;2 mysql数据库相关优化&lt;/h1&gt;

&lt;p&gt;每个玩家在数据库的角色表是一行数据，每次玩家下线时的保存数据的sql语句是这个样子的：&lt;/p&gt;

&lt;p&gt;updata role_table set val1=xxx,val2=xxx,val3=xxx &amp;hellip;.. where roleid=yyy;&lt;/p&gt;

&lt;p&gt;会更新所有字段无论是否有修改，有时玩家仅仅修改了几个字段却需要更新几十个字段。&lt;/p&gt;

&lt;p&gt;然后做了优化，把玩家的信息在上线时保存了一个备份，下线保存时会比较只把修改的字段拼到update语句中，因为使用的protobuf支持反射，所以可以写一个通用接口，不必担心字段变化。&lt;/p&gt;

&lt;h1 id=&#34;3-redis相关优化&#34;&gt;3 redis相关优化&lt;/h1&gt;

&lt;p&gt;游戏中使用了redis存储了一些数据，因为用的时redis的同步api，每次使用相当于向redis server发送一个请求，然后“原地”等候redis的返回，这里开销还是很大的。&lt;/p&gt;

&lt;p&gt;优化时时采取了redis支持的lua脚本，将一些简单逻辑让redis server来执行，来减少和redis server的网路交互次数。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>redis 使用-hiredis库使用（一） 基本篇 看完本文就可以上手工作了</title>
      <link>http://www.fpstop.com/redis/hiredis1/</link>
      <pubDate>Sun, 26 Mar 2017 00:03:10 +0800</pubDate>
      
      <guid>http://www.fpstop.com/redis/hiredis1/</guid>
      <description>

&lt;p&gt;hiredis 是redis的客户端sdk，可以让程序操作redis。本文先讲建立连接，基本的get/set命令，读写二进制，获取多个结果来讲。假设读者已经了解redis命令了。&lt;/p&gt;

&lt;p&gt;hiredis的代码也包含在redis代码中，redis\deps\hiredis目录下，接口很简单，几乎不用封装就可以用。&lt;/p&gt;

&lt;h1 id=&#34;1-连接redis数据库&#34;&gt;1 连接redis数据库&lt;/h1&gt;

&lt;h2 id=&#34;1-1-无超时时间-阻塞&#34;&gt;1.1 无超时时间，阻塞&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;redisContext *redisConnect(const char *ip, int port); 
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;1-2-设置超时时间-阻塞&#34;&gt;1.2 设置超时时间，阻塞&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;redisContext *redisConnectWithTimeout(const char *ip, int port, const struct timeval tv);  
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;1-3-非阻塞-立刻返回-也就无所谓超时&#34;&gt;1.3 非阻塞，立刻返回，也就无所谓超时&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;redisContext *redisConnectNonBlock(const char *ip, int port);
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;2-执行命令&#34;&gt;2 执行命令&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;void *redisCommand(redisContext *c, const char *format, ...);
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;2-1-返回值&#34;&gt;2.1 返回值&lt;/h2&gt;

&lt;p&gt;返回值是redisReply类型的指针：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/* This is the reply object returned by redisCommand() */
typedef struct redisReply {
    int type; /* REDIS_REPLY_* */
    PORT_LONGLONG integer; /* The integer when type is REDIS_REPLY_INTEGER */
    int len; /* Length of string */
    char *str; /* Used for both REDIS_REPLY_ERROR and REDIS_REPLY_STRING */
    size_t elements; /* number of elements, for REDIS_REPLY_ARRAY */
    struct redisReply **element; /* elements vector for REDIS_REPLY_ARRAY */
} redisReply;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;2-2-返回值类型&#34;&gt;2.2 返回值类型&lt;/h2&gt;

&lt;p&gt;type字段，包含以下几种类型：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#define REDIS_REPLY_STRING 1    //字符串
#define REDIS_REPLY_ARRAY 2     //数组，例如mget返回值
#define REDIS_REPLY_INTEGER 3   //数字类型
#define REDIS_REPLY_NIL 4       //空
#define REDIS_REPLY_STATUS 5    //状态，例如set成功返回的‘OK’
#define REDIS_REPLY_ERROR 6     //执行失败
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;3-基本命令-get-set&#34;&gt;3 基本命令，get，set&lt;/h1&gt;

&lt;h2 id=&#34;3-1-set&#34;&gt;3.1 set&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;redisReply *r1 = (redisReply*)redisCommand(c, &amp;quot;set k v&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;结果：
    type = 5&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;len = 2

str = OK
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;返回的类型5，是状态。str是OK，代表执行成功。&lt;/p&gt;

&lt;h2 id=&#34;3-2-get&#34;&gt;3.2 get&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;redisReply *r2 = (redisReply*)redisCommand(c, &amp;quot;get k&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;结果：
    type = 1&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;len = 1

str = v
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;返回的类型是1，字符串类型，str是‘v’ ，刚才保存的。&lt;/p&gt;

&lt;h1 id=&#34;4-存取二进制&#34;&gt;4 存取二进制&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;char sz[] = { 0,1,2,3,0 };
redisReply *r3 = (redisReply*)redisCommand(c, &amp;quot;set kb %b&amp;quot;,sz,sizeof(sz));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;存二进制的时候，使用%b，后面需要对应两个参数，指针和长度。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;redisReply *r4 = (redisReply*)redisCommand(c, &amp;quot;get kb&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;读取二进制的时候，和普通是一样的，str字段是地址，len字段是长度。&lt;/p&gt;

&lt;h1 id=&#34;5-存取多个值&#34;&gt;5 存取多个值&lt;/h1&gt;

&lt;h2 id=&#34;存多个值&#34;&gt;存多个值&lt;/h2&gt;

&lt;p&gt;拼接字符串就好啦&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;redisReply *r5 = (redisReply*)redisCommand(c, &amp;quot;mset k1 v1 k2 v2&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;取多个值&#34;&gt;取多个值&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;redisReply *r6 = (redisReply*)redisCommand(c, &amp;quot;mget k1 k2&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里主要看返回值里的这两个字段，代表返回值个数和起始地址：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;size_t elements; /* number of elements, for REDIS_REPLY_ARRAY */
struct redisReply **element; /* elements vector for REDIS_REPLY_ARRAY */
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;知道了以上知识，基本可以上手干活了，redis的接口还是很不错的，感觉都不用封装了。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>socket的属性设置 （持续更新）</title>
      <link>http://www.fpstop.com/redis/learn_src1/</link>
      <pubDate>Fri, 24 Mar 2017 21:47:04 +0800</pubDate>
      
      <guid>http://www.fpstop.com/redis/learn_src1/</guid>
      <description>

&lt;p&gt;今天看redis代码时，发现了如下代码，设置阻塞socket的读写超时时间，仔细一看就是简单的设置了一下socket的属性，索性把socket一些属性总结一下。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/* Set read/write timeout on a blocking socket. */
int redisSetTimeout(redisContext *c, const struct timeval tv)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;1-读超时&#34;&gt;1 读超时&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;The timeout, in milliseconds, for blocking receive calls. The default for this option is zero, which indicates that a receive operation will not time out. If a blocking receive call times out, the connection is in an indeterminate state and should be closed.
    注意，linux和windows的参数略不同。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;    bool SetRecvTimeOut(uint32 millisecond)
    {
#ifdef WIN32
        DWORD time = millisecond;
        if (setsockopt(sock, SOL_SOCKET, SO_RCVTIMEO, (const char*)&amp;amp;time, sizeof(DWORD)) == -1) {
            return false;
        }
#else
        struct timeval tv;
        tv.tv_sec = millisecond / 1000;
        tv.tv_usec = (millisecond % 1000) * 1000;
        if (setsockopt(sock, SOL_SOCKET, SO_RCVTIMEO, (const char*)&amp;amp;tv, sizeof(tv)) == -1) {
            return false;
        }
#endif
        return true;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;2-写超时&#34;&gt;2 写超时&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;The timeout, in milliseconds, for blocking send calls. The default for this option is zero, which indicates that a send operation will not time out. If a blocking send call times out, the connection is in an indeterminate state and should be closed.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;注意，linux和windows的参数略不同。

    bool SetSendTimeOut(uint32 millisecond)
    {
#ifdef WIN32
        DWORD time = millisecond;
        if (setsockopt(sock, SOL_SOCKET, SO_SNDTIMEO, (const char*)&amp;amp;time, sizeof(DWORD)) == -1) {
            return false;
        }
#else
        struct timeval tv;
        tv.tv_sec = millisecond / 1000;
        tv.tv_usec = (millisecond % 1000) * 1000;
        if (setsockopt(sock, SOL_SOCKET, SO_SNDTIMEO, (const char*)&amp;amp;tv, sizeof(tv)) == -1) {
            return false;
        }
#endif
        return true;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;3-地址重用&#34;&gt;3 地址重用&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;Allows a socket to bind to an address and port already in use. The SO_EXCLUSIVEADDRUSE option can prevent this.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;一个端口释放后会等待两分钟之后才能再被使用，SO_REUSEADDR是让端口释放后立即就可以被再次使用。&lt;/p&gt;

&lt;p&gt;p2p打洞时也需要设置这个属性。&lt;/p&gt;

&lt;p&gt;公司的网络库貌似都会设置这个属性呢。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;bool SetReUseAddr(int v)
{
    int ret = setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, (const char*)&amp;amp;v, sizeof(v));
    return 0 == ret;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;4-keepalive&#34;&gt;4 keepalive&lt;/h2&gt;

&lt;p&gt;设置心跳包，还可以指定心跳包频率，不过建议还是在逻辑层设计心跳协议，来检查连接存活。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;int val = 1;
setsockopt(fd, SOL_SOCKET, SO_KEEPALIVE, &amp;amp;val, sizeof(val))
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;5-tcp-nodelay&#34;&gt;5 TCP_NODELAY&lt;/h2&gt;

&lt;p&gt;TCP_NODELAY和TCP_CORK基本上控制了包的“Nagle化”，这里我们主要讲TCP_NODELAY.Nagle化在这里的含义是采用Nagle算法把较小的包组装为更大的帧。JohnNagle是Nagle算法的发明人，后者就是用他的名字来命名的，他在1984年首次用这种方法来尝试解决福特汽车公司的网络拥塞问题（欲了解详情请参看IETF RFC 896）。他解决的问题就是所谓的silly window syndrome，中文称“愚蠢窗口症候群”，具体含义是，因为普遍终端应用程序每产生一次击键操作就会发送一个包，而典型情况下一个包会拥有一个字节的数据载荷以及40个字节长的包头，于是产生4000%的过载，很轻易地就能令网络发生拥塞,。Nagle化后来成了一种标准并且立即在因特网上得以实现。它现在已经成为缺省配置了，但在我们看来，有些场合下把这一选项关掉也是合乎需要的。&lt;/p&gt;

&lt;p&gt;现在让我们假设某个应用程序发出了一个请求，希望发送小块数据，比如sns游戏中的点击确定按钮。我们可以选择立即发送数据或者等待产生更多的数据然后再一次发送两种策略。如果我们马上发送数据，那么交互性的以及客户/服务器型的应用程序将极大地受益。例如，当我们正在发送一个较短的请求并且等候较大的响应时，相关过载与传输的数据总量相比就会比较低，而且，如果请求立即发出那么响应时间也会快一些。以上操作可以通过设置套接字的TCP_NODELAY选项来完成，这样就禁用了Nagle算法，在nginx中设置tcp_nodelay on,注意放在http标签里。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;总之这种把小包组成大包的操作应该由逻辑层来做&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;bool SetNoDelay()
{
    int yes = 1;

    if (setsockopt(sock, IPPROTO_TCP, TCP_NODELAY, &amp;amp;yes, sizeof(yes)) == -1) {
        return false;
    }
    return true;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;6-阻塞非阻塞&#34;&gt;6 阻塞非阻塞&lt;/h2&gt;

&lt;p&gt;这个属性应该是最重要最常用的了。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    //1 :non block
    int SetNonBlock(int value)
    {
#ifndef WIN32
        int oldflags = ::fcntl(sock, F_GETFL, 0);
        /* If reading the flags failed, return error indication now. */
        if (oldflags == -1)
            return -1;

        /* Set just the flag we want to set. */
        if (value != 0)
            oldflags |= O_NONBLOCK;
        else
            oldflags &amp;amp;= ~O_NONBLOCK;
        /* Store modified flag word in the descriptor. */
        return ::fcntl(m_iSock, F_SETFL, oldflags);
#else
        if (::ioctlsocket(sock, FIONBIO, (u_long FAR*)&amp;amp;value) == SOCKET_ERROR)
        {
            return -1;
        }

        return 0;
#endif
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上文中的例子&lt;a href=&#34;https://github.com/xjp342023125/Code/blob/master/common/XSock.hpp&#34;&gt;XSock.hpp&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>香港旅游计划</title>
      <link>http://www.fpstop.com/life/hongkong_plan/</link>
      <pubDate>Tue, 21 Mar 2017 21:42:24 +0800</pubDate>
      
      <guid>http://www.fpstop.com/life/hongkong_plan/</guid>
      <description>

&lt;p&gt;澳门，香港旅游计划&lt;/p&gt;

&lt;h1 id=&#34;过关&#34;&gt;过关&lt;/h1&gt;

&lt;p&gt;4月1，拱北过关去澳门&lt;/p&gt;

&lt;p&gt;4月2，罗湖过关去香港&lt;/p&gt;

&lt;h1 id=&#34;3月31日&#34;&gt;3月31日&lt;/h1&gt;

&lt;p&gt;大连出发到深圳.&lt;/p&gt;

&lt;p&gt;猪宝宝：13：50~17：15？&lt;/p&gt;

&lt;p&gt;徐宝宝：18：20~22：20&lt;/p&gt;

&lt;p&gt;酒店：&lt;a href=&#34;http://hotels.ctrip.com/hotel/6075485.html#ctm_ref=hod_hp_sb_lst&#34;&gt;7天优品酒店&lt;/a&gt;（深圳机场T3航站楼）&lt;/p&gt;

&lt;p&gt;电话0755-29992779&lt;/p&gt;

&lt;p&gt;深圳 宝安区 西乡街道黄田岗贝工业区17号&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&#34;4月1日&#34;&gt;4月1日&lt;/h1&gt;

&lt;p&gt;坐船或者坐车&lt;/p&gt;

&lt;h2 id=&#34;汽车&#34;&gt;汽车&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://j.map.baidu.com/9J1he&#34;&gt;深圳酒店到汽车站&lt;/a&gt;:约10公里，有公交&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://bus.ctrip.com/busListn.html?from=%E6%B7%B1%E5%9C%B3&amp;amp;to=%E7%8F%A0%E6%B5%B7&amp;amp;date=2017-04-01&#34;&gt;深圳到珠海&lt;/a&gt; 宝安汽车站 到 拱北汽车客运站:价格：90 约2小时&lt;/p&gt;

&lt;p&gt;珠海拱北汽车站到拱北：就400多米&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;船&#34;&gt;船&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://j.map.baidu.com/Qb1he&#34;&gt;深圳酒店到蛇口&lt;/a&gt; 二三十公里，有公交&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://bus.ctrip.com/ship/list.html?from=%E6%B7%B1%E5%9C%B3&amp;amp;to=%E6%BE%B3%E9%97%A8&amp;amp;date=2017-04-01&amp;amp;utm_source=Ctrip_shipSearch&#34;&gt;蛇口港 到 珠海九洲港&lt;/a&gt; ：价格：120 约1小时&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://j.map.baidu.com/Sz1he&#34;&gt;珠海九洲港到拱北&lt;/a&gt; 9公里，有公交&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;入住酒店，然后去&lt;a href=&#34;http://j.map.baidu.com/4N1he&#34;&gt;拱北过关去澳门大三巴牌坊&lt;/a&gt;,3.7公里，可以不行看看澳门的街景，感受一下。也可以做公交。&lt;/p&gt;

&lt;p&gt;大三巴上面有个博物馆，还有炮台，下来以后是个商业区，有特色小吃，牛杂:)&lt;/p&gt;

&lt;p&gt;澳门有好多车可以免费接送去赌场，猪宝宝可以看看去赌场之前还想去哪，赌场夜景比较好。&lt;/p&gt;

&lt;p&gt;拱北口岸通关时间：有说6:00到次日 1：00，也有说7：00到24：00的，到时候问问。&lt;/p&gt;

&lt;p&gt;晚上回来美美睡一觉，不过酒店还没订奥。&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;澳门旅游篇&#34;&gt;澳门旅游篇&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://m.cityguide.gov.mo&#34;&gt;http://m.cityguide.gov.mo&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;大三巴牌坊&lt;/p&gt;

&lt;p&gt;大炮台：就在大三巴上面，可以花1块钱看望远镜。&lt;/p&gt;

&lt;p&gt;澳门博物馆：离大三巴牌坊也特别近，15块门票。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://j.map.baidu.com/lbBKe&#34;&gt;澳门主教座堂&lt;/a&gt;：离大三巴只有460米&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://j.map.baidu.com/yFCKe&#34;&gt;南湾公园&lt;/a&gt;:大三巴370米&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://j.map.baidu.com/PXCKe&#34;&gt;玫瑰圣母堂&lt;/a&gt;:大三巴380米&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://j.map.baidu.com/iRCKe&#34;&gt;龙环葡韵住宅式博物馆&lt;/a&gt;:公交半小时，6公里，这离威尼斯商人比较近。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://j.map.baidu.com/rlFKe&#34;&gt;官也街&lt;/a&gt;:离博物馆330米&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://j.map.baidu.com/kPFKe&#34;&gt;澳门渔人码头&lt;/a&gt;：离大三巴2.5公里&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://j.map.baidu.com/LEFKe&#34;&gt;澳门旅游塔&lt;/a&gt;：&lt;/p&gt;

&lt;h2 id=&#34;吃&#34;&gt;吃&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://j.map.baidu.com/EfCKe&#34;&gt;新马路的玛嘉烈蛋挞&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;新马路牛杂&lt;/p&gt;

&lt;p&gt;大运河（威尼斯商人三层）：【大利来记】招牌猪扒包 MOP$48/个&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://j.map.baidu.com/GCHKe&#34;&gt;义顺牛奶公司&lt;/a&gt;:双皮奶&lt;/p&gt;

&lt;h1 id=&#34;4月2日&#34;&gt;4月2日&lt;/h1&gt;

&lt;h2 id=&#34;船-1&#34;&gt;船&lt;/h2&gt;

&lt;p&gt;拱北酒到九洲港：参考上，9公里，有公交&lt;/p&gt;

&lt;p&gt;九洲港到蛇口港：参考上，120，1小时&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://j.map.baidu.com/uc3he&#34;&gt;蛇口港 到 罗湖口岸&lt;/a&gt;:约30公里，有地铁，1小时12分钟&lt;/p&gt;

&lt;h2 id=&#34;汽车-1&#34;&gt;汽车&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://bus.ctrip.com/busListn.html?from=%E7%8F%A0%E6%B5%B7&amp;amp;to=%E6%B7%B1%E5%9C%B3&amp;amp;date=2017-04-01&#34;&gt;拱北汽车客运站 到 深圳罗湖汽车客运站&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;拱北口岸离拱北汽车站很近啦，罗湖汽车站离罗湖口岸也很近。&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;罗湖口岸到酒店&#34;&gt;罗湖口岸到酒店&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://gss0.baidu.com/9fo3dSag_xI4khGko9WTAnF6hhy/zhidao/wh%3D600%2C800/sign=10911509ba096b63814c56563c03ab7c/8b82b9014a90f603695a4e613d12b31bb051ed2a.jpg&#34;&gt;地铁图&lt;/a&gt;
1 东铁线，罗湖站上车九龙塘下车.
2 观塘线，九龙塘到太子。36酒店：D出口右转，过路口，钵兰街道对面，写着鸡煲那栋楼。&lt;/p&gt;

&lt;hr /&gt;
</description>
    </item>
    
  </channel>
</rss>
