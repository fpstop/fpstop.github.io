<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>徐锦平的博客</title>
    <link>http://www.fpstop.com/</link>
    <description>Recent content on 徐锦平的博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 25 May 2017 23:11:46 +0800</lastBuildDate>
    <atom:link href="http://www.fpstop.com/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>日不落的服务器-linux下利用信号捕获崩溃</title>
      <link>http://www.fpstop.com/linux/signal/</link>
      <pubDate>Thu, 25 May 2017 23:11:46 +0800</pubDate>
      
      <guid>http://www.fpstop.com/linux/signal/</guid>
      <description>

&lt;p&gt;windows系统下的异常处理是&lt;strong&gt;try，&lt;/strong&gt;except,linux下可以用信号来模拟捕捉异常，其实我感觉还是windows下的比较好用。&lt;/p&gt;

&lt;p&gt;分两步，设置信号处理函数，设置一个还原点。&lt;/p&gt;

&lt;h1 id=&#34;设置信号处理函数&#34;&gt;设置信号处理函数&lt;/h1&gt;

&lt;p&gt;一般崩溃时都是收到这两个信号。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;::signal(SIGSEGV, KFXDoSigSEGV);
::signal(SIGFPE, KFXDoSigSEGV);
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;设置还原点-一般都是在主循环上面设置&#34;&gt;设置还原点，一般都是在主循环上面设置&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;sigjmp_buf context;//全局对象
.... 
sigsetjmp(gDoSEGV.context,1);//主循环上方

while(1)
{
    main_loop();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;发生异常时&#34;&gt;发生异常时&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;会调用我们设置的信号处理函数，然后会执行siglongjmp，跳转到我们设置的还原点，重新进入主循环。

static void KFXDoSigSEGV(int nSig)
{
    // 打印一些崩溃信息
    siglongjmp(context, 1);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;思考&#34;&gt;思考&lt;/h1&gt;

&lt;p&gt;不能完全依赖这种方法避免服务器崩溃， 不然会掩盖错误。现在的做法时捕捉到崩溃的时候，打印调用堆栈，然后通知研发计数+1，如果连续捕获到1000次崩溃，就走默认处理真正崩溃，每次捕获后立刻通知研发人员查代码。&lt;/p&gt;

&lt;p&gt;如果是低概率的崩溃事件，可以不影响游戏的其他玩家。&lt;/p&gt;

&lt;p&gt;如果是极高概率出现，1000次以后也会真正的崩溃。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>智能指针:指向基类的智能指针与指向子类的智能指针转换</title>
      <link>http://www.fpstop.com/cpp/shared_ptr/</link>
      <pubDate>Thu, 25 May 2017 06:17:57 +0800</pubDate>
      
      <guid>http://www.fpstop.com/cpp/shared_ptr/</guid>
      <description>

&lt;p&gt;以前没仔细想过这个问题，自己以前实现过的也不支持这个操作。昨天重读 &amp;lt;&lt;effective c++&gt;&amp;gt;，&lt;strong&gt;条款45时 运用成员函数模板，接受所有兼容类型&lt;/strong&gt;。发现了这个问题的实现方法。&lt;/p&gt;

&lt;h1 id=&#34;声明基类和子类-a-b&#34;&gt;声明基类和子类，A，B&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;class A
{
public:
    A()
    {
        cout &amp;lt;&amp;lt; &amp;quot;new A&amp;quot;;
    }
    ~A()
    {
        cout &amp;lt;&amp;lt; &amp;quot;del A&amp;quot;;
    }
};

class B :public A
{
public:
    B()
    {
        cout &amp;lt;&amp;lt; &amp;quot;new B&amp;quot;;
    }
    ~B()
    {
        cout &amp;lt;&amp;lt; &amp;quot;del B&amp;quot;;
    }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;子类智能指针转基类智能指针&#34;&gt;子类智能指针转基类智能指针&lt;/h1&gt;

&lt;p&gt;可以的，赋值操作也可以进行&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;std::shared_ptr&amp;lt;B&amp;gt; bbb(new B);
std::shared_ptr&amp;lt;A&amp;gt; aaa(bbb);
std::shared_ptr&amp;lt;A&amp;gt; aaa2 = bbb;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;拷贝构造时，会调用以下拷贝构造函数，is_convertible会检查是否可以转化（继承关系）。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;template&amp;lt;class _Ty2,
class = typename enable_if&amp;lt;is_convertible&amp;lt;_Ty2 *, _Ty *&amp;gt;::value,
    void&amp;gt;::type&amp;gt;
shared_ptr(const shared_ptr&amp;lt;_Ty2&amp;gt;&amp;amp; _Other) _NOEXCEPT
{   // construct shared_ptr object that owns same resource as _Other
this-&amp;gt;_Reset(_Other);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;enable_if这个关键字我还不太会，不过看效果时编译期就可以检查出是否可以转换成功。基类转子类的智能指针时无法编译通过的：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;shared_ptr&amp;lt;A&amp;gt; aaa(new A);
shared_ptr&amp;lt;B&amp;gt; bbb(aaa); // 无法转换

 error C2664: &#39;std::shared_ptr&amp;lt;B&amp;gt;::shared_ptr(std::shared_ptr&amp;lt;B&amp;gt; &amp;amp;&amp;amp;) noexcept&#39;: cannot convert argument 1 from &#39;std::shared_ptr&amp;lt;A&amp;gt;&#39; to &#39;std::nullptr_t&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;另一种转化方法-operator-t&#34;&gt;另一种转化方法：operator T*();&lt;/h1&gt;

&lt;p&gt;游戏项目中是自己实现的智能指针，没有特殊为这种转换写构造函数，而是写了的转换，在上述调用时参数自动转换成T*。
&lt;strong&gt;不过这种实现方法要求引用计数保存在对象中，而不是智能指针&lt;/strong&gt;，因为无法对隐世转换的智能指针增加计数。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>linux编译版本时日志中打印svn版本号</title>
      <link>http://www.fpstop.com/svn/linux_build_with_svn_info/</link>
      <pubDate>Thu, 25 May 2017 05:54:05 +0800</pubDate>
      
      <guid>http://www.fpstop.com/svn/linux_build_with_svn_info/</guid>
      <description>&lt;p&gt;做游戏开发，有很多时候查bug，最后都是发现时因为测试没有替补丁。所以想，如果日志里能把svn当前的版本号打印出来多好，先排除版本问题。&lt;/p&gt;

&lt;p&gt;从svn中提取信息貌似很不容易，后来想到一种取巧的方法：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;编译脚本中，调用 svn info命令，把svn输出的一个文件，命名为 svn_info.h。&lt;/li&gt;
&lt;li&gt;代码包含 svn_info.h,日志中输出svn版本号。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;脚本提取时，用grep过滤一下信息：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;DST=./Common/svn_info.h
rm -rf DST
echo &#39;#ifndef _SVN_INFO_&#39; &amp;gt; $DST
echo &#39;#define _SVN_INFO_&#39; &amp;gt;&amp;gt; $DST

VERSION=`svn info|grep Revision`
echo &#39;  #define SVNINFO &amp;quot;&#39;$VERSION&#39; &#39;$1&#39;&amp;quot; &#39; &amp;gt;&amp;gt; $DST

echo &#39;#endif&#39; &amp;gt;&amp;gt; $DST
#  
echo $VERSION
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后就会生成类似如下的文件：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#ifndef _SVN_INFO_
#define _SVN_INFO_
#define SVNINFO  &amp;quot;Revision: 11111&amp;quot;
#endif
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;很简单吧。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>protobuf的DebugString方法，汉字乱码</title>
      <link>http://www.fpstop.com/third/protobuf_string/</link>
      <pubDate>Mon, 22 May 2017 18:23:27 +0800</pubDate>
      
      <guid>http://www.fpstop.com/third/protobuf_string/</guid>
      <description>

&lt;p&gt;本文不是解决乱码问题，是要提取乱码内容。游戏上线后要做舆情分析，想收集前两日玩家游戏内聊天内容，无奈没有专门的日志，只能从网络库日志提取protobuf的内容。&lt;/p&gt;

&lt;p&gt;网络库会把每条收到的protobuf协议都调用方法，日志打印所有字段的值，但是汉子会打出类似&amp;rdquo;\346\234\211\344\272\272\345\220\227&amp;rdquo;.想把这些编码转化为能看懂的汉子。&lt;/p&gt;

&lt;h1 id=&#34;1-尝试编码转换&#34;&gt;1 尝试编码转换&lt;/h1&gt;

&lt;p&gt;游戏内的聊天文字用的是utf8的格式，不过看着上面的编码有超过256 char最大值的，看着像双字节的unicode，转成unicode后显示也是乱码，后来用utf8，ansi看都是乱码，只好从代码分析是如何打印的了。&lt;/p&gt;

&lt;h1 id=&#34;2-分析debugstring函数&#34;&gt;2 分析DebugString函数&lt;/h1&gt;

&lt;p&gt;最终会调用到下面的函数，原来是八进制的，仔细一看，确实是。所以剩下的就好做了。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// Escapes &#39;src&#39; using C-style escape sequences, and appends the escaped string
// to &#39;dest&#39;. This version is faster than calling CEscapeInternal as it computes
// the required space using a lookup table, and also does not do any special
// handling for Hex or UTF-8 characters.
// ----------------------------------------------------------------------
void CEscapeAndAppend(StringPiece src, string* dest) {
  size_t escaped_len = CEscapedLength(src);
  if (escaped_len == src.size()) {
    dest-&amp;gt;append(src.data(), src.size());
    return;
  }

  size_t cur_dest_len = dest-&amp;gt;size();
  dest-&amp;gt;resize(cur_dest_len + escaped_len);
  char* append_ptr = &amp;amp;(*dest)[cur_dest_len];

  for (int i = 0; i &amp;lt; src.size(); ++i) {
    unsigned char c = static_cast&amp;lt;unsigned char&amp;gt;(src[i]);
    switch (c) {
      case &#39;\n&#39;: *append_ptr++ = &#39;\\&#39;; *append_ptr++ = &#39;n&#39;; break;
      case &#39;\r&#39;: *append_ptr++ = &#39;\\&#39;; *append_ptr++ = &#39;r&#39;; break;
      case &#39;\t&#39;: *append_ptr++ = &#39;\\&#39;; *append_ptr++ = &#39;t&#39;; break;
      case &#39;\&amp;quot;&#39;: *append_ptr++ = &#39;\\&#39;; *append_ptr++ = &#39;\&amp;quot;&#39;; break;
      case &#39;\&#39;&#39;: *append_ptr++ = &#39;\\&#39;; *append_ptr++ = &#39;\&#39;&#39;; break;
      case &#39;\\&#39;: *append_ptr++ = &#39;\\&#39;; *append_ptr++ = &#39;\\&#39;; break;
      default:
        if (!isprint(c)) {
          *append_ptr++ = &#39;\\&#39;;
          *append_ptr++ = &#39;0&#39; + c / 64;
          *append_ptr++ = &#39;0&#39; + (c % 64) / 8;
          *append_ptr++ = &#39;0&#39; + c % 8;
        } else {
          *append_ptr++ = c;
        }
        break;
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;3-提取数据-输出&#34;&gt;3 提取数据，输出&lt;/h1&gt;

&lt;p&gt;第一步先用c++11 的正则表达式提取数据，然后再用strtol 将八进制转化输出即可，代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;quot;stdafx.h&amp;quot;
#include &amp;quot;../../../Com/CFunc.hpp&amp;quot;
#include &amp;quot;../../../Com/CStr.hpp&amp;quot;
#include &amp;quot;../../../Com/CFile.hpp&amp;quot;
#include &amp;lt;regex&amp;gt;
using namespace std;



int main()
{
    linevec_t lines;
    XReadFileLine(&amp;quot;chat.csv&amp;quot;, lines);

    std::regex reg(&amp;quot;\\\\[0-7]{3}&amp;quot;, std::regex_constants::ECMAScript);

    sregex_token_iterator end;
    for (auto s:lines)
    {
        string chat;
        sregex_token_iterator it(s.begin(), s.end(), reg);
        while (it != end)
        {
            //cout &amp;lt;&amp;lt; *it&amp;lt;&amp;lt;&amp;quot; &amp;quot;;
            string ss = *it;
            ++it;

            char sz[4] = {0};
            sz[0] = ss[1];
            sz[1] = ss[2];
            sz[2] = ss[3];
            //cout &amp;lt;&amp;lt; sz;

            int ret = strtol(sz, NULL, 8);
            chat += char(ret);
        }
        cout &amp;lt;&amp;lt; chat &amp;lt;&amp;lt; endl;
    }
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>redis 使用lua脚本提高执行效率</title>
      <link>http://www.fpstop.com/redis/redis_and_lua/</link>
      <pubDate>Sun, 21 May 2017 23:59:24 +0800</pubDate>
      
      <guid>http://www.fpstop.com/redis/redis_and_lua/</guid>
      <description>

&lt;p&gt;主要针对使用redis的同步api。&lt;/p&gt;

&lt;h1 id=&#34;redis的同步api-代价非常昂贵&#34;&gt;redis的同步api，代价非常昂贵&lt;/h1&gt;

&lt;p&gt;redis的同步api，每一次调用都是相当于一次网络通信，而且时阻塞的，如果赶上网络波动或者redis正在保存数据，会占用很多时间的。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;void *redisvCommand(redisContext *c, const char *format, va_list ap)
{
    send request...
    recv result...
    return ...;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;2-适应情景分析&#34;&gt;2 适应情景分析&lt;/h1&gt;

&lt;p&gt;我们使用时，有很多类似下面的操作&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;val1 = redis.command(&amp;quot;get key1&amp;quot;);
if(val1 &amp;gt; 10)
    redis.command(&amp;quot;set val1 100&amp;quot;);
else
    redis.command(&amp;quot;set val1 0&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;简单地说，就是&lt;strong&gt;多次redis api调用，后面的操作以来于前面的执行结果&lt;/strong&gt;。&lt;/p&gt;

&lt;h1 id=&#34;3-使用lua脚本优化&#34;&gt;3 使用lua脚本优化&lt;/h1&gt;

&lt;p&gt;redis server支持lua脚本，使用时相当于客户端把一小段lua脚本发到redis server执行，这个lua脚本可能会有多次操作。&lt;/p&gt;

&lt;p&gt;但是网络通信只有一次，redis server执行完lua脚本把结果返回给客户端，减少网络交互次数。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>游戏服务器漫谈 压力测试带来的思考</title>
      <link>http://www.fpstop.com/net/stress_net/</link>
      <pubDate>Sun, 21 May 2017 21:44:51 +0800</pubDate>
      
      <guid>http://www.fpstop.com/net/stress_net/</guid>
      <description>

&lt;p&gt;游戏终于上线啦，加班结束，来总结一下前一段时间的所学吧。先从上线前的压力测试说起。&lt;/p&gt;

&lt;h1 id=&#34;1-网络相关优化&#34;&gt;1 网络相关优化&lt;/h1&gt;

&lt;h2 id=&#34;1-1-背景&#34;&gt;1.1 背景&lt;/h2&gt;

&lt;p&gt;单位的网络库使用的时候，网络和逻辑处理是两个线程。&lt;/p&gt;

&lt;p&gt;网络线程负责：接收数据, 解析出protobuf结构，放入网络队列。&lt;/p&gt;

&lt;p&gt;逻辑线程负责：从网络队列取出protobuf，处理。&lt;/p&gt;

&lt;h2 id=&#34;1-2-思考-网络线程是否有意义&#34;&gt;1.2 思考：网络线程是否有意义？&lt;/h2&gt;

&lt;p&gt;如果网络线程处理完直接处理，其实也是可以的。但是分离网络线程会避免当逻辑线程处理过慢，导致socket接收缓冲区满了，客户端发送数据失败。不过逻辑线程处理太慢也会导致客户端发出请求没有回应。&lt;/p&gt;

&lt;h2 id=&#34;1-3-优化-逻辑线程-每次处理网络队列的数量应该有个上限&#34;&gt;1.3 优化：逻辑线程，每次处理网络队列的数量应该有个上限&lt;/h2&gt;

&lt;p&gt;逻辑线程的主循环伪代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;while(1)
{
    // 处理网络队列里的请求
    while(!pack.empty())
    {
        Msg *p = pack.pop();
        process(p);
    }
    // 一些其他的循环，例如发送ping包，每隔5分钟发送体力，libevent库的循环。。。
    check_ping();
    check_present_energy();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;压力测试时，因为逻辑线程处理的速度比网络线程慢，所以逻辑线程会一直卡在处理网路请求的循环中，因为pack永远不为空，修改方案是在while循环的条件加上一个每次处理包的个数上限，这样其他循环也会有机会执行。&lt;/p&gt;

&lt;p&gt;发现这个问题是因为测试时，服务器的状态数据是用libevent库写的一个http接口获取的，但是测试时发现调用这个接口一直超时，后来发现时因为libevent的循环一直没有执行。&lt;/p&gt;

&lt;h1 id=&#34;2-mysql数据库相关优化&#34;&gt;2 mysql数据库相关优化&lt;/h1&gt;

&lt;p&gt;每个玩家在数据库的角色表是一行数据，每次玩家下线时的保存数据的sql语句是这个样子的：&lt;/p&gt;

&lt;p&gt;updata role_table set val1=xxx,val2=xxx,val3=xxx &amp;hellip;.. where roleid=yyy;&lt;/p&gt;

&lt;p&gt;会更新所有字段无论是否有修改，有时玩家仅仅修改了几个字段却需要更新几十个字段。&lt;/p&gt;

&lt;p&gt;然后做了优化，把玩家的信息在上线时保存了一个备份，下线保存时会比较只把修改的字段拼到update语句中，因为使用的protobuf支持反射，所以可以写一个通用接口，不必担心字段变化。&lt;/p&gt;

&lt;h1 id=&#34;3-redis相关优化&#34;&gt;3 redis相关优化&lt;/h1&gt;

&lt;p&gt;游戏中使用了redis存储了一些数据，因为用的时redis的同步api，每次使用相当于向redis server发送一个请求，然后“原地”等候redis的返回，这里开销还是很大的。&lt;/p&gt;

&lt;p&gt;优化时时采取了redis支持的lua脚本，将一些简单逻辑让redis server来执行，来减少和redis server的网路交互次数。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>redis 使用-hiredis库使用（一） 基本篇 看完本文就可以上手工作了</title>
      <link>http://www.fpstop.com/redis/hiredis1/</link>
      <pubDate>Sun, 26 Mar 2017 00:03:10 +0800</pubDate>
      
      <guid>http://www.fpstop.com/redis/hiredis1/</guid>
      <description>

&lt;p&gt;hiredis 是redis的客户端sdk，可以让程序操作redis。本文先讲建立连接，基本的get/set命令，读写二进制，获取多个结果来讲。假设读者已经了解redis命令了。&lt;/p&gt;

&lt;p&gt;hiredis的代码也包含在redis代码中，redis\deps\hiredis目录下，接口很简单，几乎不用封装就可以用。&lt;/p&gt;

&lt;h1 id=&#34;1-连接redis数据库&#34;&gt;1 连接redis数据库&lt;/h1&gt;

&lt;h2 id=&#34;1-1-无超时时间-阻塞&#34;&gt;1.1 无超时时间，阻塞&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;redisContext *redisConnect(const char *ip, int port); 
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;1-2-设置超时时间-阻塞&#34;&gt;1.2 设置超时时间，阻塞&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;redisContext *redisConnectWithTimeout(const char *ip, int port, const struct timeval tv);  
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;1-3-非阻塞-立刻返回-也就无所谓超时&#34;&gt;1.3 非阻塞，立刻返回，也就无所谓超时&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;redisContext *redisConnectNonBlock(const char *ip, int port);
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;2-执行命令&#34;&gt;2 执行命令&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;void *redisCommand(redisContext *c, const char *format, ...);
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;2-1-返回值&#34;&gt;2.1 返回值&lt;/h2&gt;

&lt;p&gt;返回值是redisReply类型的指针：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/* This is the reply object returned by redisCommand() */
typedef struct redisReply {
    int type; /* REDIS_REPLY_* */
    PORT_LONGLONG integer; /* The integer when type is REDIS_REPLY_INTEGER */
    int len; /* Length of string */
    char *str; /* Used for both REDIS_REPLY_ERROR and REDIS_REPLY_STRING */
    size_t elements; /* number of elements, for REDIS_REPLY_ARRAY */
    struct redisReply **element; /* elements vector for REDIS_REPLY_ARRAY */
} redisReply;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;2-2-返回值类型&#34;&gt;2.2 返回值类型&lt;/h2&gt;

&lt;p&gt;type字段，包含以下几种类型：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#define REDIS_REPLY_STRING 1    //字符串
#define REDIS_REPLY_ARRAY 2     //数组，例如mget返回值
#define REDIS_REPLY_INTEGER 3   //数字类型
#define REDIS_REPLY_NIL 4       //空
#define REDIS_REPLY_STATUS 5    //状态，例如set成功返回的‘OK’
#define REDIS_REPLY_ERROR 6     //执行失败
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;3-基本命令-get-set&#34;&gt;3 基本命令，get，set&lt;/h1&gt;

&lt;h2 id=&#34;3-1-set&#34;&gt;3.1 set&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;redisReply *r1 = (redisReply*)redisCommand(c, &amp;quot;set k v&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;结果：
    type = 5&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;len = 2

str = OK
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;返回的类型5，是状态。str是OK，代表执行成功。&lt;/p&gt;

&lt;h2 id=&#34;3-2-get&#34;&gt;3.2 get&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;redisReply *r2 = (redisReply*)redisCommand(c, &amp;quot;get k&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;结果：
    type = 1&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;len = 1

str = v
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;返回的类型是1，字符串类型，str是‘v’ ，刚才保存的。&lt;/p&gt;

&lt;h1 id=&#34;4-存取二进制&#34;&gt;4 存取二进制&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;char sz[] = { 0,1,2,3,0 };
redisReply *r3 = (redisReply*)redisCommand(c, &amp;quot;set kb %b&amp;quot;,sz,sizeof(sz));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;存二进制的时候，使用%b，后面需要对应两个参数，指针和长度。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;redisReply *r4 = (redisReply*)redisCommand(c, &amp;quot;get kb&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;读取二进制的时候，和普通是一样的，str字段是地址，len字段是长度。&lt;/p&gt;

&lt;h1 id=&#34;5-存取多个值&#34;&gt;5 存取多个值&lt;/h1&gt;

&lt;h2 id=&#34;存多个值&#34;&gt;存多个值&lt;/h2&gt;

&lt;p&gt;拼接字符串就好啦&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;redisReply *r5 = (redisReply*)redisCommand(c, &amp;quot;mset k1 v1 k2 v2&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;取多个值&#34;&gt;取多个值&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;redisReply *r6 = (redisReply*)redisCommand(c, &amp;quot;mget k1 k2&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里主要看返回值里的这两个字段，代表返回值个数和起始地址：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;size_t elements; /* number of elements, for REDIS_REPLY_ARRAY */
struct redisReply **element; /* elements vector for REDIS_REPLY_ARRAY */
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;知道了以上知识，基本可以上手干活了，redis的接口还是很不错的，感觉都不用封装了。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>socket的属性设置 （持续更新）</title>
      <link>http://www.fpstop.com/redis/learn_src1/</link>
      <pubDate>Fri, 24 Mar 2017 21:47:04 +0800</pubDate>
      
      <guid>http://www.fpstop.com/redis/learn_src1/</guid>
      <description>

&lt;p&gt;今天看redis代码时，发现了如下代码，设置阻塞socket的读写超时时间，仔细一看就是简单的设置了一下socket的属性，索性把socket一些属性总结一下。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/* Set read/write timeout on a blocking socket. */
int redisSetTimeout(redisContext *c, const struct timeval tv)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;1-读超时&#34;&gt;1 读超时&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;The timeout, in milliseconds, for blocking receive calls. The default for this option is zero, which indicates that a receive operation will not time out. If a blocking receive call times out, the connection is in an indeterminate state and should be closed.
    注意，linux和windows的参数略不同。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;    bool SetRecvTimeOut(uint32 millisecond)
    {
#ifdef WIN32
        DWORD time = millisecond;
        if (setsockopt(sock, SOL_SOCKET, SO_RCVTIMEO, (const char*)&amp;amp;time, sizeof(DWORD)) == -1) {
            return false;
        }
#else
        struct timeval tv;
        tv.tv_sec = millisecond / 1000;
        tv.tv_usec = (millisecond % 1000) * 1000;
        if (setsockopt(sock, SOL_SOCKET, SO_RCVTIMEO, (const char*)&amp;amp;tv, sizeof(tv)) == -1) {
            return false;
        }
#endif
        return true;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;2-写超时&#34;&gt;2 写超时&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;The timeout, in milliseconds, for blocking send calls. The default for this option is zero, which indicates that a send operation will not time out. If a blocking send call times out, the connection is in an indeterminate state and should be closed.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;注意，linux和windows的参数略不同。

    bool SetSendTimeOut(uint32 millisecond)
    {
#ifdef WIN32
        DWORD time = millisecond;
        if (setsockopt(sock, SOL_SOCKET, SO_SNDTIMEO, (const char*)&amp;amp;time, sizeof(DWORD)) == -1) {
            return false;
        }
#else
        struct timeval tv;
        tv.tv_sec = millisecond / 1000;
        tv.tv_usec = (millisecond % 1000) * 1000;
        if (setsockopt(sock, SOL_SOCKET, SO_SNDTIMEO, (const char*)&amp;amp;tv, sizeof(tv)) == -1) {
            return false;
        }
#endif
        return true;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;3-地址重用&#34;&gt;3 地址重用&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;Allows a socket to bind to an address and port already in use. The SO_EXCLUSIVEADDRUSE option can prevent this.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;一个端口释放后会等待两分钟之后才能再被使用，SO_REUSEADDR是让端口释放后立即就可以被再次使用。&lt;/p&gt;

&lt;p&gt;p2p打洞时也需要设置这个属性。&lt;/p&gt;

&lt;p&gt;公司的网络库貌似都会设置这个属性呢。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;bool SetReUseAddr(int v)
{
    int ret = setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, (const char*)&amp;amp;v, sizeof(v));
    return 0 == ret;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;4-keepalive&#34;&gt;4 keepalive&lt;/h2&gt;

&lt;p&gt;设置心跳包，还可以指定心跳包频率，不过建议还是在逻辑层设计心跳协议，来检查连接存活。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;int val = 1;
setsockopt(fd, SOL_SOCKET, SO_KEEPALIVE, &amp;amp;val, sizeof(val))
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;5-tcp-nodelay&#34;&gt;5 TCP_NODELAY&lt;/h2&gt;

&lt;p&gt;TCP_NODELAY和TCP_CORK基本上控制了包的“Nagle化”，这里我们主要讲TCP_NODELAY.Nagle化在这里的含义是采用Nagle算法把较小的包组装为更大的帧。JohnNagle是Nagle算法的发明人，后者就是用他的名字来命名的，他在1984年首次用这种方法来尝试解决福特汽车公司的网络拥塞问题（欲了解详情请参看IETF RFC 896）。他解决的问题就是所谓的silly window syndrome，中文称“愚蠢窗口症候群”，具体含义是，因为普遍终端应用程序每产生一次击键操作就会发送一个包，而典型情况下一个包会拥有一个字节的数据载荷以及40个字节长的包头，于是产生4000%的过载，很轻易地就能令网络发生拥塞,。Nagle化后来成了一种标准并且立即在因特网上得以实现。它现在已经成为缺省配置了，但在我们看来，有些场合下把这一选项关掉也是合乎需要的。&lt;/p&gt;

&lt;p&gt;现在让我们假设某个应用程序发出了一个请求，希望发送小块数据，比如sns游戏中的点击确定按钮。我们可以选择立即发送数据或者等待产生更多的数据然后再一次发送两种策略。如果我们马上发送数据，那么交互性的以及客户/服务器型的应用程序将极大地受益。例如，当我们正在发送一个较短的请求并且等候较大的响应时，相关过载与传输的数据总量相比就会比较低，而且，如果请求立即发出那么响应时间也会快一些。以上操作可以通过设置套接字的TCP_NODELAY选项来完成，这样就禁用了Nagle算法，在nginx中设置tcp_nodelay on,注意放在http标签里。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;总之这种把小包组成大包的操作应该由逻辑层来做&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;bool SetNoDelay()
{
    int yes = 1;

    if (setsockopt(sock, IPPROTO_TCP, TCP_NODELAY, &amp;amp;yes, sizeof(yes)) == -1) {
        return false;
    }
    return true;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;6-阻塞非阻塞&#34;&gt;6 阻塞非阻塞&lt;/h2&gt;

&lt;p&gt;这个属性应该是最重要最常用的了。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    //1 :non block
    int SetNonBlock(int value)
    {
#ifndef WIN32
        int oldflags = ::fcntl(sock, F_GETFL, 0);
        /* If reading the flags failed, return error indication now. */
        if (oldflags == -1)
            return -1;

        /* Set just the flag we want to set. */
        if (value != 0)
            oldflags |= O_NONBLOCK;
        else
            oldflags &amp;amp;= ~O_NONBLOCK;
        /* Store modified flag word in the descriptor. */
        return ::fcntl(m_iSock, F_SETFL, oldflags);
#else
        if (::ioctlsocket(sock, FIONBIO, (u_long FAR*)&amp;amp;value) == SOCKET_ERROR)
        {
            return -1;
        }

        return 0;
#endif
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上文中的例子&lt;a href=&#34;https://github.com/xjp342023125/Code/blob/master/common/XSock.hpp&#34;&gt;XSock.hpp&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>香港旅游计划</title>
      <link>http://www.fpstop.com/life/hongkong_plan/</link>
      <pubDate>Tue, 21 Mar 2017 21:42:24 +0800</pubDate>
      
      <guid>http://www.fpstop.com/life/hongkong_plan/</guid>
      <description>

&lt;p&gt;澳门，香港旅游计划&lt;/p&gt;

&lt;h1 id=&#34;过关&#34;&gt;过关&lt;/h1&gt;

&lt;p&gt;4月1，拱北过关去澳门&lt;/p&gt;

&lt;p&gt;4月2，罗湖过关去香港&lt;/p&gt;

&lt;h1 id=&#34;3月31日&#34;&gt;3月31日&lt;/h1&gt;

&lt;p&gt;大连出发到深圳.&lt;/p&gt;

&lt;p&gt;猪宝宝：13：50~17：15？&lt;/p&gt;

&lt;p&gt;徐宝宝：18：20~22：20&lt;/p&gt;

&lt;p&gt;酒店：&lt;a href=&#34;http://hotels.ctrip.com/hotel/6075485.html#ctm_ref=hod_hp_sb_lst&#34;&gt;7天优品酒店&lt;/a&gt;（深圳机场T3航站楼）&lt;/p&gt;

&lt;p&gt;电话0755-29992779&lt;/p&gt;

&lt;p&gt;深圳 宝安区 西乡街道黄田岗贝工业区17号&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&#34;4月1日&#34;&gt;4月1日&lt;/h1&gt;

&lt;p&gt;坐船或者坐车&lt;/p&gt;

&lt;h2 id=&#34;汽车&#34;&gt;汽车&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://j.map.baidu.com/9J1he&#34;&gt;深圳酒店到汽车站&lt;/a&gt;:约10公里，有公交&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://bus.ctrip.com/busListn.html?from=%E6%B7%B1%E5%9C%B3&amp;amp;to=%E7%8F%A0%E6%B5%B7&amp;amp;date=2017-04-01&#34;&gt;深圳到珠海&lt;/a&gt; 宝安汽车站 到 拱北汽车客运站:价格：90 约2小时&lt;/p&gt;

&lt;p&gt;珠海拱北汽车站到拱北：就400多米&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;船&#34;&gt;船&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://j.map.baidu.com/Qb1he&#34;&gt;深圳酒店到蛇口&lt;/a&gt; 二三十公里，有公交&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://bus.ctrip.com/ship/list.html?from=%E6%B7%B1%E5%9C%B3&amp;amp;to=%E6%BE%B3%E9%97%A8&amp;amp;date=2017-04-01&amp;amp;utm_source=Ctrip_shipSearch&#34;&gt;蛇口港 到 珠海九洲港&lt;/a&gt; ：价格：120 约1小时&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://j.map.baidu.com/Sz1he&#34;&gt;珠海九洲港到拱北&lt;/a&gt; 9公里，有公交&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;入住酒店，然后去&lt;a href=&#34;http://j.map.baidu.com/4N1he&#34;&gt;拱北过关去澳门大三巴牌坊&lt;/a&gt;,3.7公里，可以不行看看澳门的街景，感受一下。也可以做公交。&lt;/p&gt;

&lt;p&gt;大三巴上面有个博物馆，还有炮台，下来以后是个商业区，有特色小吃，牛杂:)&lt;/p&gt;

&lt;p&gt;澳门有好多车可以免费接送去赌场，猪宝宝可以看看去赌场之前还想去哪，赌场夜景比较好。&lt;/p&gt;

&lt;p&gt;拱北口岸通关时间：有说6:00到次日 1：00，也有说7：00到24：00的，到时候问问。&lt;/p&gt;

&lt;p&gt;晚上回来美美睡一觉，不过酒店还没订奥。&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;澳门旅游篇&#34;&gt;澳门旅游篇&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://m.cityguide.gov.mo&#34;&gt;http://m.cityguide.gov.mo&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;大三巴牌坊&lt;/p&gt;

&lt;p&gt;大炮台：就在大三巴上面，可以花1块钱看望远镜。&lt;/p&gt;

&lt;p&gt;澳门博物馆：离大三巴牌坊也特别近，15块门票。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://j.map.baidu.com/lbBKe&#34;&gt;澳门主教座堂&lt;/a&gt;：离大三巴只有460米&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://j.map.baidu.com/yFCKe&#34;&gt;南湾公园&lt;/a&gt;:大三巴370米&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://j.map.baidu.com/PXCKe&#34;&gt;玫瑰圣母堂&lt;/a&gt;:大三巴380米&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://j.map.baidu.com/iRCKe&#34;&gt;龙环葡韵住宅式博物馆&lt;/a&gt;:公交半小时，6公里，这离威尼斯商人比较近。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://j.map.baidu.com/rlFKe&#34;&gt;官也街&lt;/a&gt;:离博物馆330米&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://j.map.baidu.com/kPFKe&#34;&gt;澳门渔人码头&lt;/a&gt;：离大三巴2.5公里&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://j.map.baidu.com/LEFKe&#34;&gt;澳门旅游塔&lt;/a&gt;：&lt;/p&gt;

&lt;h2 id=&#34;吃&#34;&gt;吃&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://j.map.baidu.com/EfCKe&#34;&gt;新马路的玛嘉烈蛋挞&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;新马路牛杂&lt;/p&gt;

&lt;p&gt;大运河（威尼斯商人三层）：【大利来记】招牌猪扒包 MOP$48/个&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://j.map.baidu.com/GCHKe&#34;&gt;义顺牛奶公司&lt;/a&gt;:双皮奶&lt;/p&gt;

&lt;h1 id=&#34;4月2日&#34;&gt;4月2日&lt;/h1&gt;

&lt;h2 id=&#34;船-1&#34;&gt;船&lt;/h2&gt;

&lt;p&gt;拱北酒到九洲港：参考上，9公里，有公交&lt;/p&gt;

&lt;p&gt;九洲港到蛇口港：参考上，120，1小时&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://j.map.baidu.com/uc3he&#34;&gt;蛇口港 到 罗湖口岸&lt;/a&gt;:约30公里，有地铁，1小时12分钟&lt;/p&gt;

&lt;h2 id=&#34;汽车-1&#34;&gt;汽车&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://bus.ctrip.com/busListn.html?from=%E7%8F%A0%E6%B5%B7&amp;amp;to=%E6%B7%B1%E5%9C%B3&amp;amp;date=2017-04-01&#34;&gt;拱北汽车客运站 到 深圳罗湖汽车客运站&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;拱北口岸离拱北汽车站很近啦，罗湖汽车站离罗湖口岸也很近。&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;罗湖口岸到酒店&#34;&gt;罗湖口岸到酒店&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://gss0.baidu.com/9fo3dSag_xI4khGko9WTAnF6hhy/zhidao/wh%3D600%2C800/sign=10911509ba096b63814c56563c03ab7c/8b82b9014a90f603695a4e613d12b31bb051ed2a.jpg&#34;&gt;地铁图&lt;/a&gt;
1 东铁线，罗湖站上车九龙塘下车.
2 观塘线，九龙塘到太子。36酒店：D出口右转，过路口，钵兰街道对面，写着鸡煲那栋楼。&lt;/p&gt;

&lt;hr /&gt;
</description>
    </item>
    
    <item>
      <title>网络库接口思索</title>
      <link>http://www.fpstop.com/think/net_interface/</link>
      <pubDate>Sun, 19 Mar 2017 19:40:51 +0800</pubDate>
      
      <guid>http://www.fpstop.com/think/net_interface/</guid>
      <description>

&lt;p&gt;自从linux出现了epoll，windows的完成端口，网络编程好多年没有什么变化了。本文结合工作中遇到的问题，说说网络库的接口的一些思索。&lt;/p&gt;

&lt;h1 id=&#34;1-背景&#34;&gt;1 背景&lt;/h1&gt;

&lt;p&gt;因为做的是fps类的网游的服务器，游戏里跑，跳，开枪等都是由客户端引擎同步函数实现，没有我什么事，所以主要的逻辑都很简单，一些活动，商城购买，聊天等逻辑，可以说没有什么难点，因为项目的周期比较长，一共有三套网络库在使用。。。有封装boost的，还有老同事自己封装的两套。自从linux出现了epoll，windows的完成端口，网络编程好多年没有什么变化了。这里主要讨论的是异步的网络编程。&lt;/p&gt;

&lt;h1 id=&#34;2-我心目中的网络库的功能&#34;&gt;2 我心目中的网络库的功能&lt;/h1&gt;

&lt;h2 id=&#34;2-1-通知上层网络事件-连接-断开-可读-可写&#34;&gt;2.1 通知上层网络事件：连接，断开，可读，可写。&lt;/h2&gt;

&lt;p&gt;基本的epoll已经实现了这些最基本的功能，简单的封装一下即可。
库会告诉上层目前可读啦，可写啦，可以接收连接啦，已经连上啦，但是不会帮上层去做这些事情，只是告诉你可以做了。&lt;/p&gt;

&lt;h2 id=&#34;2-2-在2-1基础上-网络事件到来时-帮助我们做一些事情&#34;&gt;2.2 在2.1基础上，网络事件到来时，帮助我们做一些事情&lt;/h2&gt;

&lt;p&gt;例如可读写时，自动从系统读缓冲区把数据读好，或者把用户写缓存写入系统的写缓冲区，或者调用accept接受一个连接。&lt;/p&gt;

&lt;h2 id=&#34;2-3-分包&#34;&gt;2.3 分包&lt;/h2&gt;

&lt;p&gt;我们知道在网络通信时,tcp是基于流的，分包只是我们逻辑上的把字节流分成若干部分。发送方发了两个包，有可能接收方1次收到了两个包，也有可能接收方分3次才把第一个包接受完，并接收了部分第2个包。一般我们都会在每个包的前两个字节里加上这个包的长度，这样接收方可以根据这个长度把收到的字节流区分成若干个包。
而逻辑层使用时，不应该处理这些，应该等网络层判断收到一个完整的包以后，再通知逻辑层去处理。
但是这样有个缺点，网络库就需要规定定义协议长度的规则，不过一般都是在包头加若干个字节定义长度。
例如我们手游项目用的是protobuf协议，但是也需要在头部加两个字节代表长度。&lt;/p&gt;

&lt;p&gt;未完待续。。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>windows编译redis</title>
      <link>http://www.fpstop.com/redis/windows%E7%BC%96%E8%AF%91redis/</link>
      <pubDate>Sun, 12 Mar 2017 19:31:50 +0800</pubDate>
      
      <guid>http://www.fpstop.com/redis/windows%E7%BC%96%E8%AF%91redis/</guid>
      <description>

&lt;p&gt;假设大家都已经了解redis了，本文只讲redis的windows上的编译。&lt;/p&gt;

&lt;h1 id=&#34;1-windows编译redis&#34;&gt;1.windows编译redis&lt;/h1&gt;

&lt;h2 id=&#34;1-1下载&#34;&gt;1.1下载&lt;/h2&gt;

&lt;p&gt;微软维护了一个windows版本，地址在&lt;a href=&#34;https://github.com/MSOpenTech/redis&#34;&gt;https://github.com/MSOpenTech/redis&lt;/a&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;The Redis project does not officially support Windows.
However, the Microsoft Open Tech group develops and maintains this Windows port targeting Win64.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;redis官方不支持windows编译，但是微软维护了一个windows版本。既然这个出现在redis官网上，想必也是认可的。最起码用来研究学习时没问题的。&lt;/p&gt;

&lt;h2 id=&#34;1-2-编译&#34;&gt;1.2 编译&lt;/h2&gt;

&lt;p&gt;可以用vs2015 直接打开工程文件
- server：&amp;rdquo;\redis-2.8_win\msvs\RedisServer.sln&amp;rdquo;
- Hiredis异步例子：&amp;rdquo;\redis-2.8_win\msvs\HiredisExample\HiredisExample.sln&amp;rdquo;&lt;/p&gt;

&lt;p&gt;server 很顺利的编译通过，但是Hiredis异步例子编译时报了一个错误,是个类型重定义错误。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;\src\win32_interop\win32_types.h(37): error C2371: &#39;off_t&#39;: redefinition; different basic types
&amp;gt;c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\sys\types.h(42): note: see declaration of &#39;off_t&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;很明显，是自己定义的类型和默认的类型重复了。打开 win32_types.h 文件看看：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/* The Posix version of Redis defines off_t as 64-bit integers, so we do the same.
 * On Windows, these types are defined as 32-bit in sys/types.h under and #ifndef _OFF_T_DEFINED
 * So we define _OFF_T_DEFINED at the project level, to make sure that that definition is never included.
 * If you get an error about re-definition, make sure to include this file before sys/types.h, or any other
 * file that include it (eg wchar.h).
 * _off_t is also defined #ifndef _OFF_T_DEFINED, so we need to define it here.
 * It is used by the CRT internally (but not by Redis), so we leave it as 32-bit.
 */
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;原来，微软团队发现redis在Posix体系下，off_t被定义成64位，而在windows下被sys\types.h文件定义成32位。&lt;/p&gt;

&lt;p&gt;sys\types.h&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#ifndef _OFF_T_DEFINED
    #define _OFF_T_DEFINED

    typedef long _off_t; // file offset value

    #if !__STDC__
        typedef _off_t off_t;
    #endif
#endif
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后windows团队就在工程属性里定义了_OFF_T_DEFINED （So we define _OFF_T_DEFINED at the project level），使32位的不生效，用自己定义在文件的，但是为什么还是出现重定义了呢？&lt;/p&gt;

&lt;p&gt;因为他们忘记在工程属性里定义啦，加回来就行拉。。。忘记定义了这个宏，所以默认的就生效了，自己也定义一份，当然编不过了。。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
